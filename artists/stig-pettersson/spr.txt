Manual for Raytrace in spr.ufm spr.ucl


When you have loaded the module then load the outer coloring Raytrace.ucl in spr. This is done by clicking on the three small dots in Properties-Outside. Then load the gradient Greyscale 2 from the Standard library. This is done by rightclicking on the gradient and choose "past special". 

In the gradient the darkest color should be to the left and the brightest to the right. The Greyscale 2 gradient is a perfect example. One can of course change the colors in the gradient but still keep the darkest to the left and the lightest to the right. This is because in raytracing you have a lightsource and the angle between the object (fractal) and the lightsource decides the lightness of the color. If the object is facing away it will be dark and if it faces towards the lightsource it will be light. And the module will adress the gradient so better keep it okay.

In the default setting the background coloring and the object coloring will be the same. It would of course be desirable to have the possibility to color them independently of each other. For that purpose we will need two gradients. So let us start with creating a second gradient.

Rightklick on the gradient and choose insert. Then put a dot in the middle of the gradient. It should be on index 200. Not location 200 but index 200. The middle. Then move the three RGB-threads in that position to the bottom. Insert a new dot to the left of the one before (index 199). Move the three threads in this position to the top. If you have done this right you should now have a gradient that has two fields that looks exactly the same. Both shall start from the bottom left and end at the top right. You now have two independent gradients. Ok?

In the coloring routine (Properties-Outside) you can now choose the option Two gradients.
Change one thread a little in the left gradient and you should see the background change.
The background will always be the leftmost gradient.

For the most fractals this will be enough but maybe (I said maybe) you are interested in Cubics. Cubics are made of two different sets. And it would be nice to be able to color them independently of each other. Then we will have to make one more gradient.


Start with moving the two middle points to index 132 and 133. (The gradient is 400 long and 133 is approximately one third of 400). Insert a new dot at 266. As before move the threads down. And insert a new one to the left at 265 and move the threads up. You should now have three gradients.
Now choose Three gradients in the colorroutine. To see the effect of this one you need a cubic. But if you have not changed the default there should be one there. And then change the colors little in the two rightmost gradients.

Not so hard - or? 

In the raytrace module there is also a twodimensional routine. This will always use the rightmost gradient. If you use cubics you would maybe prefer to have one gradient for this too. Okay. Then the border-dots should be at 100, 200, 300. And of course the dots beside them that you should move up. Then you should have four gradients and should choose Four gradients in the color-routine.

The twodimensional routine does not need the coloringmodule. You can use any colorroutine and gradient for 2d-s. It is only when one switches back and forth between 3d and 2d that this is interesting. And if you don´t use Cubics then three gradients will be enough. Again - background uses the leftmost gradient and 2d the rightmost.

This was about the gradients. Well - one more thing. For 2d there is also a scale to change the speed of colors. Works best between 0 and 1 (0.5 for example).


So .. let us look at what kind of goodies we have here.


Formula.

Activate Properties-Formula. At Parameter you will se Formula and below it Cubic. If you push the little arrow to the right of Cubic a list of different formulas will show. You can choose between Cubic, Juliabrot, Quaternion, Hypernion, Quatbrot, and Hyperbrot (and some more). You cannot do very much with the last two ones but it is always good to have seen them at least ones in a life-time. But these are the formulas you can work with. (At least right now.)

Now click at the arrow to the right of formula and you will have:


Fourthdim.

We are now dealing with fourdimensional objects. We are just looking at them in three and two dimensions. Therefore a coordinateaxis shall point into the fourth dimension. For quaternions and hypernions the fourth one (b-imag or zk) is most commonly used. When you change this option you simply changes the coord-system and gets a new view of the system. Feel free to experiment.


Fourthdim-value.

You can move through the fourth axis and by doing so you will get different threedimensional cuts of the fourdimensional space. You do this by entering a number here. Keep it between -1 and 1. 0.3 for example.


z-center.

The z-axis moves from your screen-window into the monitor. It is the one that gives the depth to the picture. The x and y-axis you already know. It is the horisontal and vertical dirction of your screen. You can move in the virtual space by entering a number into z-center. If it is a positive number you will move deeper into the monitor. A negative number goes in the other direction.


z-init.

This has only significance for cubics. Cubics are made of two sets. +m and-m. Which one is dependent on if z is initiated with the parameter +a or -a. (Don´t tell me you understood this). Anyway..  +a gives one set of the cubics and -a gives the other. In default they look very much the same. If you choose both then there are no problems and both sets will be rendered. You can color them independently by choosing three or four gradients. If you choose one or two gradients they will have the same color. The formula for cubics is: z->z^3-3a^2z+b


View.

Here you can choose between 3d, 2d-center and 2d-screen. 3d is the normal threedimensional view. 2d-center is the twodimensional view that comes if you cut the figure in two equal halves.
2d-screen is the 2d-view of the structures that touches the screen in 3d. If there are no structures touching the screen this will be more or less empty.


Background.

You can have two types of backgrounds. Outside or inside. In outside the background is traced as the object and will change in color dependently of the position of the lightsource (and your work with the gradient). In inside coloring the background will be only one color that you can choose by clicking on the little beetle in Properties-Inside. You can also choose an inside coloring routine. This can give rather spectacular effects.


Screentouch.

If you want the structures that touches the screen to have a special color then you can choose this and color them with Properties-Inside (the beetle) or an inside routine.


cr, ci, cj, ck.

These are the parameters for the quaternions and hypernions. They can also be used to initiate z in Quatbrots (I invented this name..I think.. :) and Hyperbrots (this too). Try a number between -1 and 1 (0.3 for example).


x, y, z-rotation

Rotates the plane. The x-axis goes from the left to the right of the screen. Look at it from behind and turn it clockwise. After a while the screen (or the picture in it) will face the floor. This happens with positive angles (in degrees from 0 to 360). Negative will turn it anticlockwise. The y-axis goes from the floor to the roof and the z-axis from the screen into the monitor.


Local rotation.

As default there is local rotation. It means that the figure will rotate from the center where you are, not necessarily from origo. This can cause big problems for the mind. As Ultra Fractal does not know that it suddenly has become a ray-tracer then it will presume that everything is as it used to be. But it isn´t. If you have rotated the system 90 degrees with the y-axis then the x-axis has become the z-axis and the z-axis has become the x-axis. This can be tricky to handle. If you move the system in x-direction then it will instead move in the z-direction. This phenomenon will increase with higher angles. Unfortunately there is nothing I can do about it. But it is a good training in three-dimensional thinking.
To avoid those terrible phenomenons you can choose not to have Local rotation on. Then things are normal again. But the system will only rotate around origo.


Light x, y, z

The coordinate where you have the lightsource. Raytracing is like nature itself. What you do is to calculate the angle between the lightsource and the object on the screen. Then the illumination will be proportional to that angle. You put lightsource by giving values to these parameters. As you are sitting on the negative side of the z-axis (depth) then you better give z-light a negative value (like -3.0). Otherwise things can get unnecassarily dark. But, of course, sometimes that can be fun too.


Screendepth.

The depth of the screen (z-axis) in virtual pixels. Default is set to 320. The same as screenlength (x-axis). For quaternions and hypernions this value can be rather modest as they are rather kind to render. With cubics the values mostly must be increased as they are more sensitive and have more small structures. What I mean is that if you enlarge the screen to 640*480 you mostly can do with a depth of 320. But with cubics it can be good to increase it at least to 480.
If the depth is too little one pixel can be too big to catch the smaller structures and scaling artefacts can be there too. This is also a question of speed as the rendering time increases with greater depth. As usual it is a choice between speed and beauty.


z-distance

This time the length of the parameter z-axis. Normally about 4.0 (as the x-axis). In default the z-axis will go from -2 to 2 that gives a lengt of 4.


z-magnify

As a difference from my earlier 3d-module I don´t have automatic scaling on as default. If you want to magnify in the z-direction too you have to do it by hand by lowering the value of z-distance. Or you could have z-magnify on. The reason for magnify in z-direction too is that you can avoid scaling-artefacts that appears when there is too much difference between the xy-plane and the depth. One can avoid them by magnify in z-direction too. But this can also cause structures to disappear in the enviroment because they are out of the bounds for the scale. I use to magnify until I have reached the right view and then I try to set the z-distance as small as possible without any desirable structures disappear. If there are scaling-artefacts I use to increase the z-depth in pixels instead. Scaling-artefacts looks, for example like stairs and with cubics they can be chains of unbound mandelbrots. You will notice them. They disappears when the proportions gets normal again.


Autoscaling.

Sets the depth in pixels according to the screenlength and the parameter-length of the x-axis.
If you increase the size of the screen this will also increase the depth (and the rendering-time) if autoscaling is on.
The same - if you magnify the screen this will automatically increase the depth in pixels. If you are magnifying so take it easy with this one. The depth of the screen can easily grow very large. If you have z-magnify on then there are no problems. The reason for this option is also to avoid scaling artefacts.


Precision.

Precision is a sort of fine-tuning in raytracing. The higher value the better pictures. But one does not have to overdo it. The best is to test the differences between different values. If the precision is high the depth does normally not need to be too high. At least not for quaternions and hypernions. When one is tracing one is walking until one has walked into the set. Then one has to go backwards until the very border of the set is reached. This backstepping is done normally with a smaller step than a pixel. If the precision is 1 then you walk backwards with the length of a pixel and there is no precision. With 2 the pixellength is divided by two and the steps get smaller. One can see Screendepth as the precision to walk forward to the set and Precision the finer precision when one shall reach the very border of the set. Default 10. I use 30 or 40 when rendering. When I have a real pearl I can use 100 (and go to sleep).

A way to see the effect of precision is to choose the Quaternion-formula and put cr, ci, cj, ck all to zero. Then you will have a globe. Put the precision to 1. Now this globe will look like the landscape on the moon. As you increase the precision the surface will go smoother and smoother. There are of course times when the lowest precision can be very effectful. But not very often.


Delta

The difference in length between the point at the set and the surrounding points that is used to calculate the normal plane. Normally this shall be 1 that is a pixel. The reason this parameter still is here is that I used it to test the difference between different lengths and I have simply not removed it. If one increases it above 1 the result will normally be a darker picture and if one decreases it a lighter picture.


Bailout.

The normal bailout-value used in calculations of the location of the set. Don´t set it too high without reason as calculation time will increase. Should not be lower than 4.


The originally sourcecode to this raytracer comes from a quaternion-generator written by Gill:
http://home.hia.no/~fgill/

Thanks to Terry Gintz and Gill.

And as always ... if you are interested in the "Cubics" you are always welcome to visit Ingvar Kullbergs Cubic Tutorial at: http://w1.111.telia.com/~u11109996/CubTut/cubictut.html


Stig








