comment {
Formulae by Davka
}

dav-Mandelbrot {
; 05Aug02 Davka
; From the UF help file

init:
  z = 0
loop:
  z = z * z + #pixel
bailout:
  |z| < 4
default:
  title = "Mandelbrot"
}

dav-MandN {
; 05Aug02 Davka
; Mandelbrot with z raised to
; an arbitrary power

init:
  z = 0
  
loop:
  z = z ^ @power + #pixel
  
bailout:
  |z| < 4
  
default:
  title = "MandN"
  
  param power
    default = 2.0
    caption = "Exponent"
    hint = "z -> z ^ Exponent"
  endparam
}

dav-MandFunc {
; 05Aug02 Davka
; Mandelbrot with z ^ 2
; replaced by func(z)

init:
  z = 0
  
loop:
  z = @func1(z) + #pixel
  
bailout:
  |z| < 4
  
default:
  title = "MandFunc"
  
  func func1
    caption = "Function"
    default = sqr()
  endfunc
}

dav-MandCompose2Funcs {
; 05Aug02 Davka
; Mandelbrot with z ^ 2
; replaced by func1( func2(z) )

init:
  z = 0
  
loop:
  z = @func1(@func2(z)) + #pixel
  
bailout:
  |z| < 4
  
default:
  title = "MandCompose2Funcs"
  
  func func1
    caption = "First Function"
    default = ident()
  endfunc
  
  func func2
    caption = "Second Function"
    default = sqr()
  endfunc
}

dav-MandCompose3Funcs {
; 05Aug02 Davka
; Mandelbrot with z ^ 2
; replaced by func1( func2( func3(z) ) )

init:
  z = 0
  
loop:
  z = @func1(@func2(@func3((z)))) + #pixel
  
bailout:
  |z| < 4
  
default:
  title = "MandCompose3Funcs"
  
  func func1
    caption = "First Function"
    default = ident()
  endfunc
  
  func func2
    caption = "Second Function"
    default = ident()
  endfunc
  
  func func3
    caption = "Third Function"
    default = sqr()
  endfunc
}

dav-Julia7 {
; 05Aug02 Davka
; z = z^7 - 1
; from Clifford A. Pickover

init:
  z = #pixel
 
loop:
  z = z^7 - 1

bailout:
  |z| < 4

default:
  title = "Julia7"
}

dav-MandZ {
; 07Aug02 Davka
; z = z^z + c
; from Clifford A. Pickover

init:
  z = 0
 
loop:
  z = z^z + #pixel

bailout:
  |z| < 4

default:
  title = "MandZ"

switch:
  type = "dav-JuliaZ"
  c = #pixel
}


dav-JuliaZ {
; 07Aug02 Davka
; z = z^z + c
; from Clifford A. Pickover

init:
  z = #pixel
 
loop:
  z = z^z + @c

bailout:
  |z| < 4

default:
  title = "JuliaZ"

  param c
    default = (0, 0)    
    caption = "c"
    hint = "z -> z^z + c"
  endparam
}

dav-tdds1 {
; 13Aug02 Davka
; Time-discrete dynamical system.
; From Pickover

init:
  float x = real(#pixel)
  float y = imag(#pixel)

loop:
  float oldx = x
  float oldy = y
  x = oldx - 0.1 * sin(oldy + sin(3 * oldy))
  y = oldy + 0.1 * sin(oldx + sin(3 * oldx))
  z = x + flip(y)
  
bailout:
  |z| < 1000

default:
  title = "tdds1"
}

dav-tdds2 {
; 06Oct02 Davka    Removed references to oldy2
; 13Aug02 Davka
; Time-discrete dynamical system.
; Inspired by Pickover.

init:
  float x = real(#pixel)
  float y = imag(#pixel)
  float oldx = x
  float oldy = y
  float oldx1 = x
  float oldy1 = y
  float oldx2 = x
;  float oldy2 = y  This var written to, but never read back

loop:
  oldx2 = oldx1
  oldx1 = oldx
  oldx = x
;  oldy2 = oldy1    This var written to, but never read back
  oldy1 = oldy
  oldy = y
  x = oldx2 - 0.2 * ( sin(oldy + sin(2 * oldy)) )
  y = oldy1 + 0.2 * ( sin(oldx + sin(2 * oldx)) )
  z = x + flip(y)
  
bailout:
  |z| < 100000

default:
  title = "tdds2"
}

dav-tdds3 {
; 13Aug02 Davka
; Time-discrete dynamical system.
; From Pickover.

init:
  float x = real(#pixel)
  float y = imag(#pixel)

loop:
  float oldx = x
  float oldy = y
  x = oldx - 0.1 * ( sin(oldy^2 + sin(3 * oldy)) )
  y = oldy + 0.1 * ( sin(oldx^2 + sin(3 * oldx)) )
  z = x + flip(y)
  
bailout:
  |z| < 1000

default:
  title = "tdds3"
}

dav-tdds4 {
; 21Aug02 Davka
; Time-discrete dynamical system.
; Use inside coloring.
; Inspired by Pickover.

init:
  float x = real(#pixel)
  float y = imag(#pixel)

loop:
  float oldx = x
  float oldy = y
  x = oldx - @mult * ( sin(oldy^2 + sin(3 * oldy)) / oldx )
  y = oldy + @mult * ( sin(oldx^2 + sin(3 * oldx)) / oldy )
  z = x + flip(y)
  
bailout:
  |z| < 1000

default:
  title = "tdds4"
  magn = 0.1

  
  param mult
    default = 0.1
    min = 1.0e-20
    max = 1.0 
    caption = "Multiplier"
    hint = "0 < Multiplier <= 1"
  endparam
}


dav-multitdds {
; 21Aug02 Davka    Variations 1-9
; 05Oct02 Davka    Added variations 10-15
; 08Oct02 Davka    Added variations 16-
; Multiple time-discrete dynamical systems.
; Use inside coloring.
; The akl:Distances coloring algorithm works okay.
; So does akl:Elliptic Harlequin Coloring.
; So does akl:Pick Over 153.
;
; For variation 1, use a multiplier around .005
; For variation 2, use a multiplier around .005
; For variation 3, use a multiplier around .005
; For variation 4, use a multiplier around .005
; For variation 5, use a multiplier around .05
; For variation 6, use a multiplier around .05
;
; 7 and 8 are both cool.  They aren't crowded
; around the line y = x, like the ones above.
; For variations 7 and 8, use a multiplier around .05
; 
; 9 is nice with a multiplier of .02
; 10 (?)
; 11 (?)
; 12 (?)
;
; 13 is good around 0.08
; Try both inside and outside coloring.
;
;14 (?)
;
;15 is good around .005
;Inside coloring.  Try Gaussian Integer.
;
;16 is good around .04.  Try akl:Distances
;
init:
  float x = real(#pixel)
  float y = imag(#pixel)

loop:
  if @which == 0
    float oldx = x
    float oldy = y
    x = oldx - @mult * ( cos(oldy + tan(oldy^3)) )
    y = oldy + @mult * ( cos(oldx + tan(oldx^3)) )
  elseif @which == 1
    float oldx = x
    float oldy = y
    x = oldx - @mult * ( sin(oldy / cos(2 * oldy)) )
    y = oldy + @mult * ( sin(oldx / cos(2 * oldx)) )
  elseif @which == 2
    float oldx = x
    float oldy = y
    x = oldx - @mult *  ( tan(oldy^2) * sin(oldy)^2 - log(oldy) )
    y = oldy + @mult *  ( tan(oldx^2) * sin(oldx)^2 - log(oldx) )
  elseif @which == 3
    float oldx = x
    float oldy = y
    x = oldx - @mult *  ( tan(1.0 / oldy^0.5) * sin(oldy)^0.5 - 1.0 / log(oldy) )
    y = oldy + @mult *  ( tan(1.0 / oldx^0.5) * sin(oldx)^0.5 - 1.0 / log(oldx) )
  elseif @which == 4
    float oldx = x
    float oldy = y
    x = oldx - @mult *  ( (1.0 / sin(oldy)^0.5) - 1.0 / log(oldy) )
    y = oldy + @mult *  ( (1.0 / sin(oldx)^0.5) - 1.0 / log(oldx) )
  elseif @which == 5
    float oldx = x
    float oldy = y
    x = oldx - @mult * (sin(oldy) + cos(oldy)) / (sin(oldy)-cos(oldy))
    y = oldy + @mult * (sin(oldx) + cos(oldx)) / (sin(oldx)-cos(oldx))
  elseif @which == 6
    float oldx = x
    float oldy = y
    x = oldx - @mult * (sin(oldy) + cos(oldy)) / atan2(oldy + flip(oldx))
    y = oldy + @mult * (sin(oldx) + cos(oldx)) / atan2(oldy + flip(oldx))
  elseif @which == 7
    float oldx = x
    float oldy = y
    x = oldx - @mult * (sin(oldy) + cos(oldy)) / atan2(oldy + flip(oldx))
    y = oldy + @mult * (sin(oldx) + cos(oldx)) / atan2(oldx + flip(oldy))
  elseif @which == 8
    float oldx = x
    float oldy = y
    x = oldx - @mult * sin(oldy + cos(oldy)^3 + cos(oldy)^2 + 5 * sin(oldy))
    y = oldy + @mult * sin(oldx + cos(oldx)^3 + cos(oldx)^2 + 5 * sin(oldx))
  elseif @which == 9
    float oldx = x
    float oldy = y
    x = oldx - @mult * 1.0 / sin(oldy + cos(oldy)^3 + cos(oldy)^2 + 5 * sin(oldy))
    y = oldy + @mult * 1.0 / sin(oldx + cos(oldx)^3 + cos(oldx)^2 + 5 * sin(oldx))
  elseif @which == 10
    float oldx = x
    float oldy = y
    x = oldx - @mult * log(1.0 / sin(oldy))
    y = oldy + @mult * log(1.0 / sin(oldx))
  elseif @which == 11
    float oldx = x
    float oldy = y
    x = oldx - @mult * sin(oldy^3) + cos(10 * oldy^2)
    y = oldy + @mult * cos(oldx^3) + sin(10 * oldx^2)
  elseif @which == 12
    float oldx = x
    float oldy = y
    x = oldx - @mult * (sin(sqrt(oldy) + sin(10 * oldy)))
    y = oldy + @mult * (cos(sqrt(oldx) + cos(10 * oldx)))
  elseif @which == 13
    float oldx = x
    float oldy = y
    x = oldx - @mult * (sin(sqr(oldy) - tan(10 * cotan(oldy))))
    y = oldy + @mult * (cos(sqr(oldx) + tan(10 * cotan(oldx))))
  elseif @which == 14
    float oldx = x
    float oldy = y
    x = oldx - @mult * (y)
    y = oldy + @mult * (x)
;
; Written 08Oct02
;
  elseif @which == 15
    float oldx = x
    float oldy = y
    x = oldx - @mult * (5 * cos(7 * oldy + .5) * cos(3 * oldy - .1))
    y = oldy + @mult * (5 * cos(2.2 * oldx + .3) * cos(4.1 * oldx - .15))
  elseif @which == 16
    float oldx = x
    float oldy = y
    x = oldx - @mult * (1 * cos(7 * oldy + .5) + 2 * cos(3 * oldy - .1) + 6 * cos(12 * oldy))
    y = oldy + @mult * (1* cos(5.2 * oldx + .3) + 2 * cos(4.1 * oldx - .15) + 6 * cos(13 * oldx))
  elseif @which == 17
    float oldx = x
    float oldy = y
    x = oldx - @mult * ( 5 * cos(2 * oldy + 4 * cos(13 * oldy + .5 * cos(20 * oldy))) )
    y = oldy + @mult * ( 5 * cos(1 * oldx + 4 * cos(13 * oldx + .5 * cos(20 * oldy))) )
 endif
  
  z = x + flip(y)

bailout:
  |z| < 1000

default:
  title = "Multi tdds"
  magn = 0.1
  periodicity = 0
  method = multipass

  param which
    caption = "Variation"
    default = 0
    enum = "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" \
            "14" "15" "16" "17" "18"
  endparam
  
  param mult
    default = 0.005
    min = 1.0e-20
    max = 1.0 
    caption = "Multiplier"
    hint = "0 < Multiplier <= 1"
  endparam
}

dav-3func-tdds {
; 08Oct02 Davka      Created.
; TDDS where the value added to the vector component is the composition of 3 functions.
; The "amplitude" and "frequency" of each function is a parameter.  Each function takes the
; result of the next function as its "phase shift".  The terms amplitude, frequency and
; phase shift only apply if the function is sin or cos; otherwise they are more properly called
; scale factors and an offset.
;
; Use inside coloring.
;
; Try akl:Distances for coloring.
;
; If the image looks like fuzz, reduce the multiplier.
; If the image doesn't have enough detail, increase the multiplier.
;
; The overall shape produced by this TDDS is a disc (a filled circle.)  The bailout
; is the radius of the disk.  If you zoom out so you can see the edge of the disc, and
; then vary the bailout, you will see the circle change size.  Try changing the bailout to 100.
;
; This formula is designed to use sin or cos for the 3 functions (but try them all!)
;
; Put a zero in amplitudes 2 or 3 to make this a 1-function or 2-function TDDS.  
; This speeds up the formula.

init:
  float x = real(#pixel)
  float y = imag(#pixel)
  
loop:
  float oldx = x
  float oldy = y

  x = oldx + @multiplier * \
          @amplitude1 * real(@function1(@frequency1 * oldy + \
          @amplitude2 * real(@function2(@frequency2 * oldy + \
          @amplitude3 * real(@function3(@frequency3 * oldy))) )))

  y = oldy - @multiplier * \
          @amplitude1 * real(@function1(@frequency1 * oldx + \
          @amplitude2 * real(@function2(@frequency2 * oldx + \
          @amplitude3 * real(@function3(@frequency3 * oldx))) )))

  z = x + flip(y)

bailout:
  |z| < @bailout
  
default:
  title = "Three-Function TDDS"
  method = multipass
  periodicity = 0
  magn = 0.1
  
  float param bailout
    default = 1000.0
    caption = "Bailout"
  endparam
  
  float param multiplier
    default = .1
    caption = "Multiplier"
  endparam

  func function1
    default = sin()
    caption = "Function 1"
  endfunc
  
  float param amplitude1
    default = 1.0
    caption = "Amplitude 1"
  endparam
  
  float param frequency1
    default = 1.0
    caption = "Frequency 1"
  endparam
  
  func function2
    default = sin()
    caption = "Function 2"
  endfunc
  
  float param amplitude2
    default = 1.0
    caption = "Amplitude 2"
  endparam
  
  float param frequency2
    default = 1.0
    caption = "Frequency 2"
  endparam
  
  func function3
    default = sin()
    caption = "Function 3"
  endfunc
  
  float param amplitude3
    default = 1.0
    caption = "Amplitude 3"
  endparam
  
  float param frequency3
    default = 1.0
    caption = "Frequency 3"
  endparam
}

dav-d1j {
; 20Aug02 Davka

init:
  z = #pixel
 
loop:
  z = (exp(z) + sin(z))^3 / cos(z) + @c

bailout:
  |z| < 4

default:
  title = "Davka1Julia"

  complex param c
    default = (0, 0)    
    caption = "c"
  endparam
}

dav-d1m {
; 20Aug02 Davka

init:
  z = 0

loop:
  z = (exp(z) + sin(z))^3 / cos(z) + #pixel

bailout:
  |z| < 4

default:
  center = (-0.975, 0)
  magn = 0.7071
  title = "Davka1Mandelbrot"

switch:
  type = "dav-d1j"
  @c = #pixel
}

; 07Sep02 Davka
; I'm trying the trick of combining the mandelbrot and julia
; into the same formula.  Thanks to Toby Marshall, whose code
; I perused to see how the trick is done.
;
; Mode is 0 for mand, 1 for julia
; dav-d1mj {
; init:
;   if (@mode == 0)
;     z = @startSeed
;   else
;     z = #pixel
;   endif
; 
; loop:
;   if (@mode == 0)
;     z = z^2 + #pixel
;   else
;     z = z^2 + @startSeed
;   endif
; 
; bailout:
;   |z| < 4
; 
; switch:
;   StartSeed = @StartSeed
;   type = "dav-d1mj"
;   mode = switchMode
;   switchMode = mode
; 
; default:
;   title = "Davka1MandelJulia"
;   
;   int param mode
;     caption = "Current mode"
;     default = 0
;     enum = "Mandelbrot" "Julia"
;     hint = "Shows the current mode for the formula."
;   endparam
;   
;   int param switchMode
;     caption = "Switch to"
;     default = 1
;     enum = "Mandelbrot" "Julia"
;     hint = "Sets the mode to switch to using the switch function."
;   endparam
; 
;   complex param startSeed
;   caption = "Start/Seed"
;   default = (0,0)
;   hint = "Perturbation for the Mandelbrot, seed for the Julia."
;   endparam
; }
  
  