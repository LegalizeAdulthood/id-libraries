CubicParameterspace {; Stig Pettersson 1999-04-04 22:00


; The formula z=z^3-3a^2z+b contains the two complex constants a and b. Each with two parts,
; one real and one imaginary. This gives us a space with four axis, a fourdimensional space.
; From these axis we can choose any combination of two to be iterated
; and the other two are hold constant. This gives us six different planes to study.
; (a-real,a-imag), (b-real,b-imag), (a-real,b-real), (a-imag,b-imag), (a-real,b-imag) and
; (a-imag,b-real). In Properties/Formula you can choose which plane in IterPlane.
; In the default state I have a-real as x-axis, a-imag as y-axis, b-real as z-axis and
; b-imag as u-axis.
; In z-axis and u-axis you can choose where the plane shall cut the fourdimensional space.
; You can see the horisontal and vertical axis of your screen as x-axis and y-axis which 
; will be iterated, while the z-axis or the u-axis is pointing into the screen. If the z-axis is
; pointing into the screen then the u-axis is pointing into the fourth dimension. The z-axis
; and the u-axis are holding the constant you put in. Default is zero.
;
; You can rotate the space in six different ways. For example if you rotate the xy-plane it
; will be the same as pushing Alt and left mousebutton and move the mouse in Ultrafractal 
; with the default settings. One can see it as you are rotating the plane by turning the
; z-axis. If you are rotating the xz-plane you are turning the y-axis.
; 
; Projecting is like rotating but more as a cut. It will stretch the figure. I used it before
; I figured out some way to rotate the space.
;
; Flip will cut the figure 90 degrees. If you want to flip from y to z you will have to cut
; the y-value from Properties/location/center/im and paste it in flip-value. Then choose Flip
; y->z. It can be useful if one want to look at a perpendicular cut of a structure.
;
; +a is the default initial value of the iterated z. The other value is -a. In cubics there are
; always two possible initiating values. For the formula z^3-3a^2z+b it is +a and -a.
; If both are used as layers one can find interesting structures in the borders 
; where they overlap.
;
; If move on is activated you can glide at the z and u-axis by holding down Ctrl and left
; mousebutton and move the mouse. It is just a routine for observation. You cannot zoom
; the figure afterwards.
;
; In Julia plane you write the number of the plane you are in in the Re-position. If you are
; in the defaultplane (a-real, a-imag) you write 0. It was the only way I could find to send
; variables in the switch-mode.
;
; In Var to julia you write the noniterated coords. z-axis in real and u-axis in imag.
; If you have the appropriate plane in Julia plane you can now switch to Juliamode.
;
; Bailout is the limit before outside coloring.
;
; As I´m not a programmer this module is certainly full of errors. And it can´t render
; 3d-images or make coffee. But I´m working on it.
; Have fun.
; sp.

init:
  float c=0
  float d=0
  float t=0
  float aa=0
  a=0+0i
  b=0+0i
  c=real(#pixel)
  d=imag(#pixel)
  float IX=@InterX
  float IY=@InterY
  float yrot=0
  float xrot=0
  float xrotu=0
  float yrotu=0
  float zrot=0
  float uzrot=0
  float projxz=0
  float projyz=0
  float projxu=0
  float projyu=0

    IF @yrot!=0
      yrot=(@yrot%360)*pi/180
      t=cabs(c+IX*1i)      
      aa=atan2(c+IX*1i)
      aa=yrot+aa
      IF abs(aa)==pi
        c=-t
        IX=0
      ELSEIF aa==pi/2
        c=0
        IX=t
      ELSEIF aa==-pi/2
        c=0
        IX=-t
      ELSE
        c=t*cos(aa)
        IX=t*sin(aa)
      ENDIF
    ENDIF
      
    IF @xrot!=0
      xrot=(@xrot%360)*pi/180
      t=cabs(IX+d*1i)     
      aa=atan2(IX+d*1i)
      aa=xrot+aa
      IF abs(aa)==pi
        IX=-t
        d=0
      ELSEIF aa==pi/2
        IX=0
        d=t
      ELSEIF aa==-pi/2
        IX=0
        d=-t
      ELSE
        IX=t*cos(aa)
        d=t*sin(aa)
      ENDIF
    ENDIF
    
    IF @yrotu!=0
      yrotu=(@yrotu%360)*pi/180
      t=cabs(c+IY*1i)      
      aa=atan2(c+IY*1i) 
      aa=yrotu+aa
      IF abs(aa)==pi
        c=-t
        IY=0
      ELSEIF aa==pi/2
        c=0
        IY=t
      ELSEIF aa==-pi/2
        c=0
        IY=-t
      ELSE
        c=t*cos(aa)
        IY=t*sin(aa)
      ENDIF
    ENDIF
      
    IF @xrotu!=0
      xrotu=(@xrotu%360)*pi/180
      t=cabs(IY+d*1i)      
      aa=atan2(IY+d*1i) 
      aa=xrotu+aa
      IF abs(aa)==pi
        IY=-t
        d=0
      ELSEIF aa==pi/2
        IY=0
        d=t
      ELSEIF aa==-pi/2
        IY=0
        d=-t
      ELSE
        IY=t*cos(aa)
        d=t*sin(aa)
      ENDIF
    ENDIF
      
    IF @zrot!=0
      zrot=(@zrot%360)*pi/180
      t=cabs(c+d*1i)
      aa=atan2(c+d*1i)     
      aa=zrot+aa
      IF abs(aa)==pi
        c=-t
        d=0
      ELSEIF aa==pi/2
        c=0
        d=t
      ELSEIF aa==-pi/2
        c=0
        d=-t
      ELSE
        c=t*cos(aa)
        d=t*sin(aa)
      ENDIF
    ENDIF
    
     
    IF @uzrot!=0
      uzrot=(@uzrot%360)*pi/180
      t=cabs(IX+IY*1i)    
      aa=atan2(IX+IY*1i)
      aa=uzrot+aa
      IF abs(aa)==pi
        IX=-t
        IY=0
      ELSEIF aa==pi/2
        IX=0
        IY=t
      ELSEIF aa==-pi/2
        IX=0
        IY=-t
      ELSE
        IX=t*cos(aa)
        IY=t*sin(aa)
      ENDIF
    ENDIF


    IF @projxz!=0
      projxz=(@projxz%360)*pi/180
      IF @projxz==90      
        IX=c+IX
        c=0
      ELSE
        IX=c*sin(projxz)+IX
        c=c*cos(projxz)
      ENDIF
    ENDIF
  
    IF @projyz!=0
      projyz=(@projyz%360)*pi/180
      IF @projyz==90      
        IX=d+IX
        d=0
      ELSE
        IX=d*sin(projyz)+IX
        d=d*cos(projyz)
      ENDIF
    ENDIF
    
    IF @projxu!=0
      projxu=(@projxu%360)*pi/180
      IF @projxu==90      
        IY=c+IY
        c=0
      ELSE
        IY=c*sin(projxu)+IY
        c=c*cos(projxu)
      ENDIF
    ENDIF
    
    IF @projyu!=0
      projyu=(@projyu%360)*pi/180
      IF @projyu==90      
        IY=d+IY
        d=0
      ELSE
        IY=d*sin(projyu)+IY
        d=d*cos(projyu)
      ENDIF
    ENDIF
    
  IF @FLIP==1
    IX=d
    d=@FlipValue
  ELSEIF @FLIP==2
    IY=d
    d=@FlipValue
  ELSEIF @FLIP==3
    IX=c
    c=@FlipValue
  ELSEIF @FLIP==4
    IY=c
    c=@FlipValue
  ENDIF
  
  If @MovePlane == true
    IX = real(#center)
    IY = imag(#center)
  ENDIF
    
  IF @IterPlane==0
    a=c+d*1i
    b=IX+IY*1i 
  ELSEIF @IterPlane==1
    a=c+IX*1i
    b=d+IY*1i
  ELSEIF @IterPlane==2
    a=c+IX*1i
    b=IY+d*1i
  ELSEIF @IterPlane==3
    a=IX+c*1i
    b=d+IY*1i
  ELSEIF @IterPlane==4
    a=IX+c*1i
    b=Iy+d*1i
  ELSE 
    a=IX+IY*1i
    b=c+d*1i
  ENDIF
  
  IF @M==false
    z=a
  ELSE 
    z=-a
  ENDIF
    
  loop:
    z=z*z*z-3*a*a*z+b
    
bailout:
  |z|<@bailout
  
  
switch:
  type="ToCubicJulia"
  seed=#pixel
  IterPlane=IterPlane
  InterX=InterX
  InterY=InterY
  yrot=yrot
  xrot=xrot
  yrotu=yrotu
  xrotu=xrotu
  zrot=zrot
  uzrot=uzrot
  projxz=projxz
  projxu=projxu
  projyz=projyz
  projyu=projyu
  FlipValue=FlipValue
  FLIP=FLIP
  M=M
  MovePlane=MovePlane
  bailout=bailout
  
default:
  title = "Cubic Parameterspace"
  
  param IterPlane
    enum = "(a-real,a-imag)" "(a-real,b-real)" "(a-real,b-imag)" "(a-imag,breal)" \
    "(a-imag,b-imag)" "(b-real,b-imag)"
    default=0
    hint="The axis that will be plotted."
  endparam
  
  param InterX
    caption=" z-axis"
    hint="Complement to Iterative Plane.For ex. iter: a-imag,b-real this should be a-real"
    default=0.0
  endparam
  
 param InterY
    caption=" u-axis"
    hint="Complement to Iterative Plane.For iter: a-real,b-imag this should be b-real"
    default=0.0
  endparam
  
 param yrot
    caption="Rotates xz-plane."
    hint= "Rotates xyz-plane in degrees around the y-axis."
    default=0.0
 endparam
  
  param xrot
    caption="Rotates yz-plane."
    hint= "Rotates xyz-plane in degrees around the x-axes."
    default=0.0
  endparam
  
 param yrotu
    caption="Rotates xu-plane."
    hint= "Rotates the xyu-plane in degrees around the y-axis."
    default=0.0
 endparam
  
  param xrotu
    caption="Rotates yu-plane."
    hint= "Rotating xyu-plane in degrees around the x-axis."
    default=0.0
  endparam
  
  param zrot
    caption="Rotates xy-plane."
    hint= "Rotating xy-plane in degrees around the z-axis."
    default=0.0
  endparam
  
  param uzrot
    caption="Rotates uz-plane"
    hint="Rotates the uz-plane in degrees."
    default=0.0
  endparam
  
  param projxz
    caption="Project x on z."
    hint="Projecting x on z in degrees."
    default=0.0
  endparam
  
 param projxu
    caption="Project x on u."
    hint="Projecting x on u in degrees."
    default=0.0
  endparam
  
  param projyz
    caption="Project y on z."
    hint="Projecting y on z in degrees."
    default=0.0
  endparam
  
  param projyu
    caption="Project y on u."
    hint="Projecting y on u in degrees."
    default=0.0
  endparam
  
   
  param FlipValue
    caption="flip value"
    hint="Value for flip. Should be be taken from properties/location/center. \
    y for y-flip x for x-flip. \
    Don´t forget to zero the coordinate at location after flip or simply cut the coordinate."
    default=0.0
  endparam
  
  param FLIP
    enum = "No Flip" "Flip y -> z" "Flip y -> u" "Flip x -> z" "Flip x -> u"
    hint="Turns coordinateplane 90 deg. Paste the coordinate you want to flip from location. \
    Don´t forget to zero the coordinate at location after the flip or simly cut the coordinate."
    default=0
  endparam
  
  param M
    caption="-a"
    hint="Sets the sign of the initial parameter a. If set it will be negative."
    default=false
  endparam 
  
  param MovePlane
    caption = "Move On"
    default=false
    hint = "Is to play with. Be sure interceptcoords. are zero (default location).\
            Put MovePlane on. Push control as you move the area in the window \
            (hold left mousebutton down). If you move the mouse in x-direction \
            the set will move along the z-axis. In y-direction along u-axis. Enjoy." 
  endparam
  
  param bailout
    caption="bailout"
    hint="Value for bailout"
    default=100.0
    min=1
  endparam
     
  }

ToCubicJulia {
init:
  
  complex c=@seed
  complex z=#pixel
  g=@IterPlane
  d=@InterX+flip(@interY)
  IF g==0
     a=c
     b=d
  ELSEIF g==1
    a=real(c)+real(d)*1i
    b=imag(c)+imag(d)*1i
  ELSEIF g==2
    a=real(c)+real(d)*1i
    b=imag(d)+imag(c)*1i
  ELSEIF g==3
    a=real(d)+real(c)*1i
    b=imag(c)+imag(d)*1i
  ELSEIF g==4
    a=real(d)+real(c)*1i
    b=imag(d)+imag(c)*1i
  ELSE
    a=d
    b=c
  ENDIF
   
   
loop:
  z=z*z*z-3*a*a*z+b
  
bailout:
  |z|<@bailout
  
switch:
  type="CubicParameterspace"
  IterPlane=IterPlane
  InterX=InterX
  InterY=InterY
  yrot=yrot
  xrot=xrot
  yrotu=yrotu
  xrotu=xrotu
  zrot=zrot
  uzrot=uzrot
  projxz=projxz
  projxu=projxu
  projyz=projyz
  projyu=projyu
  FlipValue=FlipValue
  FLIP=FLIP
  M=M
  MovePlane=MovePlane
  bailout=bailout

default:
  title = "ToCubic Julia"
  
  param IterPlane
    enum = "(a-real,a-imag)" "(a-real,b-real)" "(a-real,b-imag)" "(a-imag,breal)" \
    "(a-imag,b-imag)" "(b-real,b-imag)"
    default=0
    hint="The axis that will be plotted."
  endparam
  
  param InterX
    caption=" z-axis"
    hint="Complement to Iterative Plane.For ex. iter: a-imag,b-real this should be a-real"
    default=0.0
  endparam
  
 param InterY
    caption=" u-axis"
    hint="Complement to Iterative Plane.For iter: a-real,b-imag this should be b-real"
    default=0.0
  endparam
  
 param yrot
    caption="Rotates xz-plane."
    hint= "Rotates xyz-plane in degrees around the y-axis."
    default=0.0
 endparam
  
  param xrot
    caption="Rotates yz-plane."
    hint= "Rotates xyz-plane in degrees around the x-axes."
    default=0.0
  endparam
  
 param yrotu
    caption="Rotates xu-plane."
    hint= "Rotates the xyu-plane in degrees around the y-axis."
    default=0.0
 endparam
  
  param xrotu
    caption="Rotates yu-plane."
    hint= "Rotating xyu-plane in degrees around the x-axis."
    default=0.0
  endparam
  
  param zrot
    caption="Rotates xy-plane."
    hint= "Rotating xy-plane in degrees around the z-axis."
    default=0.0
  endparam
  
  param uzrot
    caption="Rotates uz-plane"
    hint="Rotates the uz-plane in degrees."
    default=0.0
  endparam
  
  param projxz
    caption="Project x on z."
    hint="Projecting x on z in degrees."
    default=0.0
  endparam
  
 param projxu
    caption="Project x on u."
    hint="Projecting x on u in degrees."
    default=0.0
  endparam
  
  param projyz
    caption="Project y on z."
    hint="Projecting y on z in degrees."
    default=0.0
  endparam
  
  param projyu
    caption="Project y on u."
    hint="Projecting y on u in degrees."
    default=0.0
  endparam
  
   
  param FlipValue
    caption="flip value"
    hint="Value for flip. Should be be taken from properties/location/center. \
    y for y-flip x for x-flip. \
    Don´t forget to zero the coordinate at location after flip or simply cut the coordinate."
    default=0.0
  endparam
  
  param FLIP
    enum = "No Flip" "Flip y -> z" "Flip y -> u" "Flip x -> z" "Flip x -> u"
    hint="Turns coordinateplane 90 deg. Paste the coordinate you want to flip from location. \
    Don´t forget to zero the coordinate at location after the flip or simly cut the coordinate."
    default=0
  endparam
  
  param M
    caption="-a"
    hint="Sets the sign of the initial parameter a. If set it will be negative."
    default=false
  endparam 
  
  param MovePlane
    caption = "Move On"
    default=false
    hint = "Is to play with. Be sure interceptcoords. are zero (default location).\
            Put MovePlane on. Push control as you move the area in the window \
            (hold left mousebutton down). If you move the mouse in x-direction \
            the set will move along the z-axis. In y-direction along u-axis. Enjoy." 
  endparam
  
  param bailout
    caption="bailout"
    hint="Value for bailout"
    default=100.0
    min=1
  endparam

}

CubicJulia {
init:
  a=@areal+@aimag*1i
  b=@breal+@bimag*1i
  z=#pixel
loop:
  z=z*z*z-3*a*a*z+b  
bailout:
  |z|<@bailout
default:
  title = "Cubic Julia"
  
  param areal
    caption="a-real"
    hint="Real part of a-parameter"
    default=0.0
  endparam
  
   param aimag
    caption="a-imag"
    hint="Imaginary part of a-parameter"
    default=0.0
  endparam
  
   param breal
    caption="b-real"
    hint="Real part of b-parameter"
    default=0.0
  endparam
  
    
   param bimag
    caption="b-imag"
    hint="Imaginary part of b-parameter"
    default=0.0
  endparam
  
    
   param bailout
    caption="bailout"
    hint="Value of bailout"
    default=100.0  
  endparam
  
}

Inverse1 {
init:
  complex z=@ini
loop:
  z=recip(sqr(@myfunc(z))*#pixel)
bailout:
  |z|<@bailout
  
switch:
  type="Inverse1Julia"
  seed=#pixel
  myfunc=myfunc
  bailout=bailout
  ini=ini

default:
  title = "Inverse1"
  periodicity=0
  
  param ini
    caption = "init"
    default=(1,0)
  endparam
  
  func myfunc
    caption="function"
    default=sin()
  endfunc
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
}


Tricorn {
init:
  z=0
loop:
  z=conj(z)*conj(z)+#pixel
bailout:
  |z|<@bailout
  
  switch:
    type="JuliaTricorn"
    seed=#pixel
    bailout=bailout
default:
  title = "Tricorn"
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
}

JuliaTricorn {
init:
  z=#pixel
loop:
  z=conj(z)*conj(z)+@seed
bailout:
  |z|<@bailout
  
switch:
  type="Trihat"
  bailout=bailout
default:
  title = "JuliaTricorn"
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
}

Inverse2 {
init:
  complex z=@ini
loop:
  z=recip(@myfunc(z)*#pixel)
bailout:
  |z|<@bailout
  
switch:
  type="Inverse2Julia"
  seed=#pixel
  ini=ini
  myfunc=myfunc
  bailout=bailout
  
default:
  title = "Inverse2"
  periodicity=0
  
  param ini
    caption = "init"
    default=(1,0)
  endparam
  
  func myfunc
    caption="function"
    default=sin()
  endfunc
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
}

Inverse3 {
init:
  complex z=@ini
loop:
  z=recip(sqr(@myfunc(z)))*@a+sqr(@myfunc2(z))*@b+#pixel
bailout:
  |z|<@bailout
  
switch:
  type="Inverse3Julia"
  seed=#pixel
  ini=ini
  myfunc=myfunc
  myfunc2=myfunc2
  a=a
  b=b
  bailout=bailout

default:
  title = "Inverse3"
  periodicity=0

  param ini
    caption = "init"
    default=(1,0)
  endparam
  
  func myfunc
    caption="function"
    default=sin()
  endfunc
  
  func myfunc2
    caption="function2"
    default=cos()
  endfunc
  
  param a
    caption="a"
    default=1.0
  endparam
  
  param b
    caption="b"
    default=1.0
  endparam
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
}

NewtonSpecial {

; z->(a7z^7+a6z^6....a1z+root)/(7ad7z^6+6ad6z^5...+ad1)

; The degree of the formula is dependent of which constant "a" that is activated. To activate \
; the third degree all a-s from a4 and up shall be 0. a3 shall be (2,0). That is standard that \
; the constant a shall have the degree-1 in the real part and the imag part 0 to make it work \
; as a Newton formula. "ad" shall be (1,0). Of course one can use any number to a and ad \
; to get intresting results. \
; One can of course activate lower degrees too in combination with higher degree. \
; I have put in the possibilities to put in functions of z instead of only z. \
; To make it work as the originally Newton the function "ident" (default) shall be used. \
; Any way, some experimentation with the constants and the functions can yield great results. \
; For example: from the default values change a5 to (0,0) a4 to (4,0) a2 ad4 to (4.0) \
; and f4 to sqr. \
; You will get an Escher-like disc-structure. Great for making intresting mandala-structures. \
; Or change a5 to (0,0) a4 to (3,0) a2 to (1,0) and func4 to tanh. \
; A strange chain with "linked" rings will appear. \

init:
  z=#pixel
  oldz=(0,0)
  complex b7=(0,0)
  complex c7=(0,0)
  complex b6=(0,0)
  complex c6=(0,0)
  complex b5=(0,0)
  complex c5=(0,0)
  complex b4=(0,0)
  complex c4=(0,0)
  complex b3=(0,0)
  complex c3=(0,0)
  complex b2=(0,0)
  complex c2=(0,0)
  complex b1=(0,0)
  complex c1=(0,0)
  ; z->a7z^7+a6z^6....a1z+root/7a7z^6+6a6z^5...+a1
loop:
  oldz=z
  if @a7!=0
    b7=@a7*(@f7(z))^7
    c7=7*@ad7*(@f7(z))^6
  endif
  if @a6!=0
    b6=@a6*(@f6(z))^6
    c6=6*@ad6*(@f6(z))^5
  endif
  if @a5!=0
    b5=@a5*(@f5(z))^5
    c5=5*@ad5*(@f5(z))^4
  endif
  if @a4!=0
    b4=@a4*(@f4(z))^4
    c4=4*@ad4*(@f4(z))^3
  endif
  if @a3!=0
    b3=@a3*(@f3(z))^3
    c3=3*@ad3*(@f3(z))^2
  endif
  if @a2!=0
    b2=@a2*(@f2(z))^2
    c2=2*@ad2*@f2(z)
  endif
  if @a1!=0
    b1=@a1*@f1(z)
    c1=@ad1
  endif
  
  z=(b7+b6+b5+b4+b3+b2+b1+@root)/(c7+c6+c5+c4+c3+c2+c1)
bailout:
  |z-oldz|>@bailout
default:
  title = "Newton special"
  periodicity=0
  
  func f7
    caption="func7"
    default=ident()
    hint="Function to be used with a7"
  endfunc
  func f6
    caption="func6"
    default=ident()
    hint="Function to be used with a6"
  endfunc
  func f5
    caption="func5"
    default=ident()
    hint="Function to be used with a5"
  endfunc
  func f4
    caption="func4"
    default=ident()
    hint="Function to be used with a4"
  endfunc
  func f3
    caption="func3"
    default=ident()
    hint="Function to be used with a3"
  endfunc
  func f2
    caption="func2"
    default=ident()
    hint="Function to be used with a2"
  endfunc
  func f1
    caption="func1"
    default=ident()
    hint="Function to be used with a1"
  endfunc
  param a7
    caption="a7"
    default=(0,0)
    hint="Shall be (6,0) for an ordinary Newton of 7-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad7
    caption="ad7"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 7-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a6
    caption="a6"
    default=(0,0)
    hint="Shall be (5,0) for an ordinary Newton of 6-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad6
    caption="ad6"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 6-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a5
    caption="a5"
    default=(4,0)
    hint="Shall be (4,0) for an ordinary Newton of 5-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad5
    caption="ad5"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 5-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a4
    caption="a4"
    default=(0,0)
    hint="Shall be (3,0) for an ordinary Newton of 4-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad4
    caption="ad4"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 4-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a3
    caption="a3"
    default=(0,0)
    hint="Shall be (2,0) for an ordinary Newton of 3-d degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad3
    caption="ad3"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 3-d degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a2
    caption="a2"
    default=(0,0)
    hint="Shall be (1,0) for an ordinary Newton of 2-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad2
    caption="ad2"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 2-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a1
    caption="a1"
    default=(0,0)
    hint="Shall be (0,0) for an ordinary Newton. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad1
    caption="ad1"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param root
    caption="root"
    default=(1,0)
    hint="The root of the equation. The default is (1,0) \
         but any number can be used. It is not sure that it will work properly though. \
         A small number will mostly be good."
  endparam
  
  param bailout
    caption="bailout"
    default=0.00001
    hint="Bailout value."
   endparam

}


Stars {

; z->(a7z^7+a6z^6....a1z+#pixel)/(7ad7z^6+6ad6z^5...+ad1)

init:
  z=@zinit
  oldz=(0,0)
  complex b7=(0,0)
  complex c7=(0,0)
  complex b6=(0,0)
  complex c6=(0,0)
  complex b5=(0,0)
  complex c5=(0,0)
  complex b4=(0,0)
  complex c4=(0,0)
  complex b3=(0,0)
  complex c3=(0,0)
  complex b2=(0,0)
  complex c2=(0,0)
  complex b1=(0,0)
  complex c1=(0,0)

loop:
  oldz=z
  if @a7!=0
    b7=@a7*(@f7(z))^7
    c7=7*@ad7*(@f7(z))^6
  endif
  if @a6!=0
    b6=@a6*(@f6(z))^6
    c6=6*@ad6*(@f6(z))^5
  endif
  if @a5!=0
    b5=@a5*(@f5(z))^5
    c5=5*@ad5*(@f5(z))^4
  endif
  if @a4!=0
    b4=@a4*(@f4(z))^4
    c4=4*@ad4*(@f4(z))^3
  endif
  if @a3!=0
    b3=@a3*(@f3(z))^3
    c3=3*@ad3*(@f3(z))^2
  endif
  if @a2!=0
    b2=@a2*(@f2(z))^2
    c2=2*@ad2*@f2(z)
  endif
  if @a1!=0
    b1=@a1*@f1(z)
    c1=@ad1
  endif
  
  z=@zconst*@zfunc(z)-(b7+b6+b5+b4+b3+b2+b1+@root)/(c7+c6+c5+c4+c3+c2+c1)+#pixel
bailout:
  |z-oldz|>@bailout
default:
  title = "Stars"
  periodicity=0
  maxiter=1000
  
  func zfunc
    caption="z-func"
    default=ident()
  endfunc
  
  param zconst
    caption="z-const"
    default=(1.0,0.0)
  endparam
  
  func f7
    caption="func7"
    default=ident()
    hint="Function to be used with a7"
  endfunc
  func f6
    caption="func6"
    default=ident()
    hint="Function to be used with a6"
  endfunc
  func f5
    caption="func5"
    default=ident()
    hint="Function to be used with a5"
  endfunc
  func f4
    caption="func4"
    default=ident()
    hint="Function to be used with a4"
  endfunc
  func f3
    caption="func3"
    default=ident()
    hint="Function to be used with a3"
  endfunc
  func f2
    caption="func2"
    default=ident()
    hint="Function to be used with a2"
  endfunc
  func f1
    caption="func1"
    default=ident()
    hint="Function to be used with a1"
  endfunc
  

  
  param a7
    caption="a7"
    default=(0,0)
    hint="Shall be (6,0) for an ordinary Newton of 7-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad7
    caption="ad7"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 7-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a6
    caption="a6"
    default=(0,0)
    hint="Shall be (5,0) for an ordinary Newton of 6-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad6
    caption="ad6"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 6-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a5
    caption="a5"
    default=(4,0)
    hint="Shall be (4,0) for an ordinary Newton of 5-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad5
    caption="ad5"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 5-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a4
    caption="a4"
    default=(0,0)
    hint="Shall be (3,0) for an ordinary Newton of 4-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad4
    caption="ad4"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 4-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a3
    caption="a3"
    default=(0,0)
    hint="Shall be (2,0) for an ordinary Newton of 3-d degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad3
    caption="ad3"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 3-d degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a2
    caption="a2"
    default=(0,0)
    hint="Shall be (1,0) for an ordinary Newton of 2-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad2
    caption="ad2"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 2-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a1
    caption="a1"
    default=(0,0)
    hint="Shall be (0,0) for an ordinary Newton. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad1
    caption="ad1"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param zinit
    caption="z-init"
    default=(1,0)
    hint="Init of z. The default is (1,0) \
          but any number can be used. "
  endparam
  
  param root
    caption="root"
    default=(1,0)
    hint="The root of the equation. The default is (1,0) \
         but any number can be used. It is not sure that it will work properly though. \
         A small number will mostly be good."
  endparam

  param bailout
    caption="bailout"
    default=0.00001
    hint="Bailout value."
   endparam

}


Newtonian {

; z->(a7z^7+a6z^6....a1z+#pixel)/(7ad7z^6+6ad6z^5...+ad1)

init:
  z=@zinit
  oldz=(0,0)
  complex b7=(0,0)
  complex c7=(0,0)
  complex b6=(0,0)
  complex c6=(0,0)
  complex b5=(0,0)
  complex c5=(0,0)
  complex b4=(0,0)
  complex c4=(0,0)
  complex b3=(0,0)
  complex c3=(0,0)
  complex b2=(0,0)
  complex c2=(0,0)
  complex b1=(0,0)
  complex c1=(0,0)

loop:
  oldz=z
  if @a7!=0
    b7=@a7*(@f7(z))^7
    c7=7*@ad7*(@f7(z))^6
  endif
  if @a6!=0
    b6=@a6*(@f6(z))^6
    c6=6*@ad6*(@f6(z))^5
  endif
  if @a5!=0
    b5=@a5*(@f5(z))^5
    c5=5*@ad5*(@f5(z))^4
  endif
  if @a4!=0
    b4=@a4*(@f4(z))^4
    c4=4*@ad4*(@f4(z))^3
  endif
  if @a3!=0
    b3=@a3*(@f3(z))^3
    c3=3*@ad3*(@f3(z))^2
  endif
  if @a2!=0
    b2=@a2*(@f2(z))^2
    c2=2*@ad2*@f2(z)
  endif
  if @a1!=0
    b1=@a1*@f1(z)
    c1=@ad1
  endif
  if @second==false
    if abs(real(z))>abs(imag (z))
    z=z-@zconst*recip(@zfunc(z))-(b7+b6+b5+b4+b3+b2+b1+@root)/(c7+c6+c5+c4+c3+c2+c1)+#pixel
    else
      z=z-(b7+b6+b5+b4+b3+b2+b1+@root)/(c7+c6+c5+c4+c3+c2+c1)+#pixel
    endif
  else
    if abs(real(z))<abs(imag (z))
    z=z-@zconst*recip(@zfunc(z))-(b7+b6+b5+b4+b3+b2+b1+@root)/(c7+c6+c5+c4+c3+c2+c1)+#pixel
    else
      z=z-(b7+b6+b5+b4+b3+b2+b1+@root)/(c7+c6+c5+c4+c3+c2+c1)+#pixel
    endif
  endif
bailout:
  |z-oldz|>@bailout
default:
  title = "Newtonian"
  periodicity=0

  func zfunc
    caption="z-func"
    default=ident()
  endfunc
  
  param second
    caption="second"
    default=true
  endparam
  
  param zconst
    caption="z-const"
    default=(1.0,0.0)
  endparam
  
  func f7
    caption="func7"
    default=ident()
    hint="Function to be used with a7"
  endfunc
  func f6
    caption="func6"
    default=ident()
    hint="Function to be used with a6"
  endfunc
  func f5
    caption="func5"
    default=ident()
    hint="Function to be used with a5"
  endfunc
  func f4
    caption="func4"
    default=ident()
    hint="Function to be used with a4"
  endfunc
  func f3
    caption="func3"
    default=ident()
    hint="Function to be used with a3"
  endfunc
  func f2
    caption="func2"
    default=ident()
    hint="Function to be used with a2"
  endfunc
  func f1
    caption="func1"
    default=ident()
    hint="Function to be used with a1"
  endfunc
  

  
  param a7
    caption="a7"
    default=(0,0)
    hint="Shall be (6,0) for an ordinary Newton of 7-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad7
    caption="ad7"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 7-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a6
    caption="a6"
    default=(0,0)
    hint="Shall be (5,0) for an ordinary Newton of 6-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad6
    caption="ad6"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 6-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a5
    caption="a5"
    default=(0,0)
    hint="Shall be (4,0) for an ordinary Newton of 5-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad5
    caption="ad5"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 5-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a4
    caption="a4"
    default=(0,0)
    hint="Shall be (3,0) for an ordinary Newton of 4-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad4
    caption="ad4"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 4-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a3
    caption="a3"
    default=(2,0)
    hint="Shall be (2,0) for an ordinary Newton of 3-d degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad3
    caption="ad3"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 3-d degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a2
    caption="a2"
    default=(0,0)
    hint="Shall be (1,0) for an ordinary Newton of 2-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad2
    caption="ad2"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton of 2-th degree. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param a1
    caption="a1"
    default=(0,0)
    hint="Shall be (0,0) for an ordinary Newton. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param ad1
    caption="ad1"
    default=(1,0)
    hint="Shall be (1,0) for an ordinary Newton. \
          Can of course be something else. Is deactivated with (0,0)."
  endparam
  param zinit
    caption="z-init"
    default=(1,0)
    hint="Init of z. The default is (1,0) \
          but any number can be used. "
  endparam
  
  param root
    caption="root"
    default=(1,0)
    hint="The root of the equation. The default is (1,0) \
         but any number can be used. It is not sure that it will work properly though. \
         A small number will mostly be good."
  endparam

  param bailout
    caption="bailout"
    default=0.00001
    hint="Bailout value."
   endparam

}


exp1 {
init:
  complex z=@ini
loop:
  z=@a^@func1(z)+@func2(#pixel)

bailout:
  |z|<@bailout
  
switch:
  type="exp1Julia"
  seed=#pixel
  ini=ini
  a=a
  bailout=bailout
  func1=func1
  func2=func2

default:
  title = "exp1"
  periodicity=0

  param ini
    caption = "init"
    default=(0,0)
  endparam

  param a
    caption="value"
    default=(0.1,0.0)
  endparam
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
  
  func func1
    caption="function 1"
    default=ident()
  endfunc
  
  func func2
    caption="function 2"
    default=ident()
  endfunc
}


exp2 {
init:
  complex z=@ini
loop:
  z=@a*@func2(#pixel^@func1(z))+@b

bailout:
  |z|<@bailout

switch:
  type="exp2Julia"
  seed=#pixel
  ini=ini
  a=a
  b=b
  bailout=bailout
  func1=func1
  func2=func2

default:
  title = "exp2"
  periodicity=0

  param ini
    caption = "init"
    default=(0,0)
  endparam

  param a
    caption="value 1"
    default=(1.0,0.0)
  endparam
  
  param b
    caption="value 2"
    default=(1.0,0.0)
  endparam
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
  
  func func1
    caption="function 1"
    default=ident()
  endfunc
  
  func func2
    caption="function 2"
    default=ident()
  endfunc
  
}


3DCubic {
init:
  ccolscale=@colscale
  int nn=0
  bool apos=true
  bool aflag=false
  float zstore=0
  complex a=0
  complex b=0
  float rotx=0
  float roty=0
  float rotz=0
  float rotz=0
  float x1=0
  float y1=0
  float z1=0
  float rx=0
  float ry=0
  float z1=0
  float zlow=@zvalue-@dist/2
  float zdist=@dist/#magn
  float sinrotx=0
  float cosrotx=0
  float sinroty=0
  float cosroty=0
  float sinrotz=0
  float cosrotz=0
  if @Magnification==0
    zlow=@zvalue-zdist/2
  elseif @Magnification==1
    zlow=@zvalue-zdist
  elseif @Magnification==2
    zlow=@zvalue
  else
    zdist=@dist
  endif
  if @zaxis==0
    int zscreen=#width-1
  elseif @zaxis==1
    int zscreen=#height-1
  else 
    int zscreen=round(#width/@zlength)-1
  endif
  float scale = zdist/zscreen
  int nmax=zscreen+1
  int n=0
  int m=0
  bool nflag=false
  if @fdim>1
    a=#pixel
  else
    b=#pixel
  endif
  if (@dim2==true)&&(@localdim2==false)
    nmax=1
    zlow=@zvalue
  elseif (@dim2==true)&&(@localdim2==true)
    nmax=1
  endif
if @fdim==3
  while (n<nmax)&&(nflag==false)
    b=scale*n+zlow+@ucoord*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      a=#pixel
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(a)
         z1=real(b)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         a=real(a)+ry*1i
         b=rz+1i*@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=real(b)
         x1=real(a)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         b=rz+1i*@ucoord
         a=rx+1i*imag(a)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(a)
         y1=imag(a)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         a=rx+1i*ry
       endif
     endif
    if (@zinit==0)||(@zinit>1)
      z=a
      apos=true
    else
      z=-a
      apos=false
    endif
    if @zinit>1
      nn=0
    else
      nn=1
    endif
    repeat   
      while (m<#maxiter)&&(|z|<@bailout)
        z=z*z*z-3*a*a*z+b
        m=m+1
      endwhile
      m=0
      if |z|<@bailout
        nflag=true
      else
        nflag=false
      endif
      if nn==0
        zstore=|z|
      endif
      if @zinit>1
        if nn==0
          aflag=nflag
          nflag=false
          z=-a
        else
          if @zinit==2
            if (aflag==true)&&(nflag==true)
              if |z|<zstore
                apos=false
              else 
                apos=true
              endif
            elseif aflag==true
              apos=true
              nflag=true
            elseif (nflag==false)&&(aflag==false)
              if |z|<zstore
                apos=false
              else 
                apos=true
            endif
            else
              apos=false
            endif
          elseif @zinit==3
            if (aflag==true)&&(nflag==true)
              if |z|<zstore
                apos=false
              else
                apos=true
              endif
            elseif (aflag==false)&&(nflag==false)
              if |z|<zstore
                apos=false
              else
                apos=true
              endif
            elseif (aflag==true)&&(nflag==false)
              apos=false
            else
              aflag=true
              nflag=false
            endif
          endif
        endif
      endif     
      m=0
      nn=nn+1
    until nn==2
    nn=0
    n=n+1
  endwhile
  if @inside==false
    if nflag==true
      if apos==false
        ccolscale=@colscale2
      else
        ccolscale=@colscale
      endif 
      b=scale*(n-1)*ccolscale+zlow+@ucoord*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      a=#pixel
       if @rotx!=0
         y1=imag(a)
         z1=real(b)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         a=real(a)+ry*1i
         b=rz+1i*@ucoord 
       endif
       if @roty!=0
         z1=real(b)
         x1=real(a)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         b=rz+1i*@ucoord
         a=rx+1i*imag(a)
       endif
       if @rotz!=0
         x1=real(a)
         y1=imag(a)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         a=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    b=0
    a=0
    z=0
  endif
elseif @fdim==2
  while (n<nmax)&&(nflag==false)
    b=(scale*n+zlow)*1i+@ucoord
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      a=#pixel
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(a)
         z1=imag(b)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         a=real(a)+ry*1i
         b=rz*1i+@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=imag(b)
         x1=real(a)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         b=rz*1i+@ucoord
         a=rx+1i*imag(a)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(a)
         y1=imag(a)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         a=rx+1i*ry
       endif
     endif
    if (@zinit==0)||(@zinit>1)
      z=a
      apos=true
    else
      z=-a
      apos=false
    endif
    if @zinit>1
      nn=0
    else
      nn=1
    endif
    repeat   
      while (m<#maxiter)&&(|z|<@bailout)
        z=z*z*z-3*a*a*z+b
        m=m+1
      endwhile
      m=0
      if |z|<@bailout
        nflag=true
      else
        nflag=false
      endif
      if nn==0
        zstore=|z|
      endif
      if @zinit>1
        if nn==0
          aflag=nflag
          nflag=false
          z=-a
        else
          if @zinit==2
            if (aflag==true)&&(nflag==true)
              if |z|<zstore
                apos=false
              else 
                apos=true
              endif
            elseif aflag==true
              apos=true
              nflag=true
            elseif (nflag==false)&&(aflag==false)
              if |z|<zstore
                apos=false
              else 
                apos=true
            endif
            else
              apos=false
            endif
          elseif @zinit==3
            if (aflag==true)&&(nflag==true)
              if |z|<zstore
                apos=false
              else
                apos=true
              endif
            elseif (aflag==false)&&(nflag==false)
              if |z|<zstore
                apos=false
              else
                apos=true
              endif
            elseif (aflag==true)&&(nflag==false)
              apos=false
            else
              aflag=true
              nflag=false
            endif
          endif
        endif
      endif     
      m=0
      nn=nn+1
    until nn==2
    nn=0
    n=n+1
  endwhile
  if @inside == false
    if nflag==true
      if apos==false
        ccolscale=@colscale2
      else
        ccolscale=@colscale
      endif 
      b=(scale*(n-1)*ccolscale+zlow)*1i+@ucoord
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      a=#pixel
       if @rotx!=0
         y1=imag(a)
         z1=imag(b)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         a=real(a)+ry*1i
         b=rz*1i+@ucoord
       endif
       if @roty!=0
         z1=imag(b)
         x1=real(a)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         b=rz*1i+@ucoord
         a=rx+1i*imag(a)
       endif
       if @rotz!=0
         x1=real(a)
         y1=imag(a)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         a=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    b=0
    a=0
    z=0
  endif
elseif @fdim==1
  while (n<nmax)&&(nflag==false)
    a=scale*n+zlow+@ucoord*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      b=#pixel
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(b)
         z1=real(a)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         b=real(b)+ry*1i
         a=rz+1i*@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=real(a)
         x1=real(b)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         a=rz+1i*@ucoord
         b=rx+1i*imag(b)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(b)
         y1=imag(b)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         b=rx+1i*ry
       endif
     endif
    if (@zinit==0)||(@zinit>1)
      z=a
      apos=true
    else
      z=-a
      apos=false
    endif
    if @zinit>1
      nn=0
    else
      nn=1
    endif
    repeat   
      while (m<#maxiter)&&(|z|<@bailout)
        z=z*z*z-3*a*a*z+b
        m=m+1
      endwhile
      m=0
      if |z|<@bailout
        nflag=true
      else
        nflag=false
      endif
      if nn==0
        zstore=|z|
      endif
      if @zinit>1
        if nn==0
          aflag=nflag
          nflag=false
          z=-a
        else
          if @zinit==2
            if (aflag==true)&&(nflag==true)
              if |z|<zstore
                apos=false
              else 
                apos=true
              endif
            elseif aflag==true
              apos=true
              nflag=true
            elseif (nflag==false)&&(aflag==false)
              if |z|<zstore
                apos=false
              else 
                apos=true
            endif
            else
              apos=false
            endif
          elseif @zinit==3
            if (aflag==true)&&(nflag==true)
              if |z|<zstore
                apos=false
              else
                apos=true
              endif
            elseif (aflag==false)&&(nflag==false)
              if |z|<zstore
                apos=false
              else
                apos=true
              endif
            elseif (aflag==true)&&(nflag==false)
              apos=false
            else
              aflag=true
              nflag=false
            endif
          endif
        endif
      endif     
      m=0
      nn=nn+1
    until nn==2
    nn=0
    n=n+1
  endwhile
  if @inside == false
    if nflag==true
      if apos==false
        ccolscale=@colscale2
      else
        ccolscale=@colscale
      endif 
      a=scale*(n-1)*ccolscale+zlow+@ucoord*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      b=#pixel
       if @rotx!=0
         y1=imag(b)
         z1=real(a)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         b=real(b)+ry*1i
         a=rz+1i*@ucoord
       endif
       if @roty!=0
         z1=real(a)
         x1=real(b)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         a=rz+1i*@ucoord
         b=rx+1i*imag(b)
       endif
       if @rotz!=0
         x1=real(b)
         y1=imag(b)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         b=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    a=0
    b=0
    z=0
  endif
else
  while (n<nmax)&&(nflag==false)
    a=@ucoord+(scale*n+zlow)*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      b=#pixel
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(b)
         z1=imag(a)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         b=real(b)+ry*1i
         a=rz*1i+@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=imag(a)
         x1=real(b)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         a=rz*1i+@ucoord
         b=rx+1i*imag(b)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(b)
         y1=imag(b)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         b=rx+1i*ry
       endif
     endif
    if (@zinit==0)||(@zinit>1)
      z=a
      apos=true
    else
      z=-a
      apos=false
    endif
    if @zinit>1
      nn=0
    else
      nn=1
    endif
    repeat   
      while (m<#maxiter)&&(|z|<@bailout)
        z=z*z*z-3*a*a*z+b
        m=m+1
      endwhile
      m=0
      if |z|<@bailout
        nflag=true
      else
        nflag=false
      endif
      if nn==0
        zstore=|z|
      endif
      if @zinit>1
        if nn==0
          aflag=nflag
          nflag=false
          z=-a
        else
          if @zinit==2
            if (aflag==true)&&(nflag==true)
              if |z|<zstore
                apos=false
              else 
                apos=true
              endif
            elseif aflag==true
              apos=true
              nflag=true
            elseif (nflag==false)&&(aflag==false)
              if |z|<zstore
                apos=false
              else 
                apos=true
            endif
            else
              apos=false
            endif
          elseif @zinit==3
            if (aflag==true)&&(nflag==true)
              if |z|<zstore
                apos=false
              else
                apos=true
              endif
            elseif (aflag==false)&&(nflag==false)
              if |z|<zstore
                apos=false
              else
                apos=true
              endif
            elseif (aflag==true)&&(nflag==false)
              apos=false
            else
              aflag=true
              nflag=false
            endif
          endif
        endif
      endif     
      m=0
      nn=nn+1
    until nn==2
    nn=0
    n=n+1
  endwhile
  if @inside==false
    if nflag==true
      if apos==false
        ccolscale=@colscale2
      else
        ccolscale=@colscale
      endif 
      a=@ucoord+(scale*(n-1)*ccolscale+zlow)*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      b=#pixel
       if @rotx!=0
         y1=imag(b)
         z1=imag(a)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         b=real(b)+ry*1i
         a=rz*1i+@ucoord
       endif
       if @roty!=0
         z1=imag(a)
         x1=real(b)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         a=rz*1i+@ucoord
         b=rx+1i*imag(b)
       endif
       if @rotz!=0
         x1=real(b)
         y1=imag(b)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         b=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    a=0
    b=0
    z=0
  endif
endif
if @zinit==0
  z=a
elseif @zinit==1
  z=-a
elseif @zinit>1
  if apos==true
    z=a
  else
    z=-a
  endif
endif

loop:
  z=z*z*z-3*a*a*z+b
  
bailout:
  |z|<@bailout
  
default:
  title = "3DCubic"
  
  param fdim
    enum="a-real" "a-imag" "b-real" "b-imag"
    hint="The axis that shall point into the fourth dimension"
    default=3
    max=3
    min=0
  endparam
  
  param dim2
    caption="2-dimensional"
    hint="Renders 2-dimensional cubic"
    default=false
  endparam
  
  param localdim2
    caption="Local dim2-pos."
    hint="If true the landing position in dim-2 will be there you are. Otherwise it will \
          where z-value is. The default is z-value."
    default=false
  endparam
  
  param zvalue
    caption="z-value"
    hint="The midpoint at the z-axis. Default is 0."
    default=0.0
  endparam
  
  param ucoord
    caption="u-coord"
    hint="The coordinat of the fourth dimensions axis."
    default=0.0
  endparam
  
  param rotx
    caption="x-rot"
    hint="Rotates yz-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param roty
    caption="y-rot"
    hint="Rotates zx-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param rotz
    caption="z-rot"
    hint="Rotates xy-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param zinit
    enum="+a" "-a" "both" "CCL"
    hint="The initial a in cubics can be +a or -a or both. Default is both. When both, the \
    total set is rendered.If CCL then where both overlap."
    default=2
  endparam
  
  
  param Magnification
    enum="auto" "z-low locked" "z-high locked" "free"
    hint="If auto then a surrounding around z-value will be magnified. If z-low is locked only \
          z-high will be acted on. If z-high is locked only z-low will be acted on. \
          If free you have to manage it by balancing z-dist."
    default=0
    max=3
    min=0
  endparam
  
  param inside
    caption="Inside filter."
    default=false
    hint="Shall be activated if inside coloring shall be used. Gives the same effect as \
          Color scaling = 1.0. The set will be solid."
  endparam
  
  param colscale
    caption="Color scaling."
    hint="The control over the coloring of the set according to the initial parameter +a.\
          Between 0 and 1. If 1 the color is solid."
    default=0.97
    max=1.0
    min=0
  endparam
  
  param colscale2
    caption="Color scaling 2."
    hint="The control over the coloring of the set according to the initial parameter -a.\
          Between 0 and 1. If 1 the color is solid."
    default=0.97
    max=1.0
    min=0
  endparam
  
  param solid
    caption="Solid outer color"
    hint="Gives only one color outside the set. Default is true. It is the fastest option. \
          Mathematically no outer structures is allowed that do not belong to the overlapping \
          two sets from +a and -a (Cubic Connectedness Locus). We do an exception in 2-d \
          because we shall be able to explore the set in a normal way."
    default=true
  endparam
  
  param dist
    caption="z-dist"
    hint="The distance in z-direction that shall be plotted. Default is 4.0"
    default=4.0
  endparam
  
  param zaxis
    enum="Screen-width" "Screen-height" "Free"
    default=1
    hint="Length in pixels of z-axis. Can be as Screen-width or Screen-height or free. \
          If free choose the length-factor in z-length. Default is Screen-height. \
          If free then z-axis is calculated by Screenwidth/zlengthfactor."
  endparam
  
  param zlength
    caption="z-length-factor"
    hint="Is active if zaxis if Free. If the pattern is too messy choose a lower value here. \
    default is 2.0  The length of axis is calculated by dividing Screenwidth by \
    zlengthfactor"
    default=2.0
    min=1e-10
  endparam  
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=100.0
  endparam
}


3DJulia {
init:
  ccolscale=@colscale
  complex z=0
  complex c=0
  complex zz=0
  float rotx=0
  float roty=0
  float rotz=0
  float rotz=0
  float x1=0
  float y1=0
  float z1=0
  float rx=0
  float ry=0
  float z1=0
  float zlow=@zvalue-@dist/2
  float zdist=@dist/#magn
  float sinrotx=0
  float cosrotx=0
  float sinroty=0
  float cosroty=0
  float sinrotz=0
  float cosrotz=0
  if @Magnification==0
    zlow=@zvalue-zdist/2
  elseif @Magnification==1
    zlow=@zvalue-zdist
  elseif @Magnification==2
    zlow=@zvalue
  else
    zdist=@dist
  endif
  if @zaxis==0
    int zscreen=#width-1
  elseif @zaxis==1
    int zscreen=#height-1
  else 
    int zscreen=round(#width/@zlength)-1
  endif
  float scale = zdist/zscreen
  int nmax=zscreen+1
  int n=0
  int m=0
  bool nflag=false
  if @fdim>1
    c=#pixel
  else
    z=#pixel
  endif
  if (@dim2==true)&&(@localdim2==false)
    nmax=1
    zlow=@zvalue
  elseif (@dim2==true)&&(@localdim2==true)
    nmax=1
  endif
if @fdim==3
  while (n<nmax)&&(nflag==false)
    z=scale*n+zlow+@ucoord*1i
    c=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(c)
         z1=real(z)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         c=real(c)+ry*1i
         z=rz+1i*@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=real(z)
         x1=real(c)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         z=rz+1i*@ucoord
         c=rx+1i*imag(c)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(c)
         y1=imag(c)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         c=rx+1i*ry
       endif
     endif 
     zz=z
      while (m<#maxiter)&&(|z|<@bailout)
        z=z*z+c
        m=m+1
      endwhile
      if |z|<@bailout
        nflag=true
      else
        nflag=false
      endif    
      m=0
      n=n+1
  endwhile
  z=zz
  if @inside==false
    if nflag==true
      z=scale*(n-1)*ccolscale+zlow+@ucoord*1i
      c=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         y1=imag(c)
         z1=real(z)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         c=real(c)+ry*1i
         z=rz+1i*@ucoord 
       endif
       if @roty!=0
         z1=real(z)
         x1=real(c)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         z=rz+1i*@ucoord
         c=rx+1i*imag(c)
       endif
       if @rotz!=0
         x1=real(c)
         y1=imag(c)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         c=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    c=0
    z=0
  endif
elseif @fdim==2
  while (n<nmax)&&(nflag==false)
    z=(scale*n+zlow)*1i+@ucoord
    c=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(c)
         z1=imag(z)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         c=real(c)+ry*1i
         z=rz*1i+@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=imag(z)
         x1=real(c)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         z=rz*1i+@ucoord
         c=rx+1i*imag(c)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(c)
         y1=imag(c)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         c=rx+1i*ry
       endif
     endif
     zz=z
      while (m<#maxiter)&&(|z|<@bailout)
        z=z*z+c
        m=m+1
      endwhile
      m=0
      if |z|<@bailout
        nflag=true
      else
        nflag=false
      endif    
      m=0
      n=n+1
  endwhile
  z=zz
  if @inside == false
    if nflag==true
      z=(scale*(n-1)*ccolscale+zlow)*1i+@ucoord
      c=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         y1=imag(c)
         z1=imag(z)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         c=real(c)+ry*1i
         z=rz*1i+@ucoord
       endif
       if @roty!=0
         z1=imag(z)
         x1=real(c)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         z=rz*1i+@ucoord
         c=rx+1i*imag(c)
       endif
       if @rotz!=0
         x1=real(c)
         y1=imag(c)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         c=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    c=0
    z=0
  endif
elseif @fdim==1
  while (n<nmax)&&(nflag==false)
    c=scale*n+zlow+@ucoord*1i
    z=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(z)
         z1=real(c)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         z=real(z)+ry*1i
         c=rz+1i*@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=real(c)
         x1=real(z)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         c=rz+1i*@ucoord
         z=rx+1i*imag(z)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(z)
         y1=imag(z)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         z=rx+1i*ry
       endif
     endif
     zz=z
      while (m<#maxiter)&&(|z|<@bailout)
        z=z*z+c
        m=m+1
      endwhile
      m=0
      if |z|<@bailout
        nflag=true
      else
        nflag=false
      endif    
      m=0
    n=n+1
  endwhile
  z=zz
  if @inside==false
    if nflag==true
      c=scale*(n-1)*ccolscale+zlow+@ucoord*1i
      z=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         y1=imag(z)
         z1=real(c)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         z=real(z)+ry*1i
         c=rz+1i*@ucoord
       endif
       if @roty!=0
         z1=real(c)
         x1=real(z)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         c=rz+1i*@ucoord
         z=rx+1i*imag(z)
       endif
       if @rotz!=0
         x1=real(z)
         y1=imag(z)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         z=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    c=0
    z=0
  endif
else
  while (n<nmax)&&(nflag==false)
    c=@ucoord+(scale*n+zlow)*1i
    z=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(z)
         z1=imag(c)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         z=real(z)+ry*1i
         c=rz*1i+@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=imag(c)
         x1=real(z)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         c=rz*1i+@ucoord
         z=rx+1i*imag(z)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(z)
         y1=imag(z)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         z=rx+1i*ry
       endif
     endif 
     zz=z
      while (m<#maxiter)&&(|z|<@bailout)
        z=z*z+c
        m=m+1
      endwhile
      m=0
      if |z|<@bailout
        nflag=true
      else
        nflag=false
      endif   
      m=0
    n=n+1
  endwhile
  z=zz
  if @inside==false
    if nflag==true
      c=@ucoord+(scale*(n-1)*ccolscale+zlow)*1i
      z=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         y1=imag(z)
         z1=imag(c)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         z=real(z)+ry*1i
         c=rz*1i+@ucoord
       endif
       if @roty!=0
         z1=imag(c)
         x1=real(z)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         c=rz*1i+@ucoord
         z=rx+1i*imag(z)
       endif
       if @rotz!=0
         x1=real(z)
         y1=imag(z)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         z=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    c=0
    z=0
  endif
endif

loop:
  z=z*z+c
  
bailout:
  |z|<@bailout
  
default:
  title = "3DJulia"
  
  param fdim
    enum="c-real" "c-imag" "z-real" "z-imag"
    hint="The axis that shall point into the fourth dimension"
    default=0
    max=3
    min=0
  endparam
  
  param dim2
    caption="2-dimensional"
    hint="Renders 2-dimensional Juliabrot"
    default=false
  endparam
  
  param localdim2
    caption="Local dim2-pos."
    hint="If true the landing position in dim-2 will be there you are. Otherwise it will \
          where z-value is. The default is z-value."
    default=false
  endparam
  
  param zvalue
    caption="z-value"
    hint="The midpoint at the z-axis. Default is 0."
    default=0.0
  endparam
  
  param ucoord
    caption="u-coord"
    hint="The coordinat of the fourth dimensions axis."
    default=0.0
  endparam
  
  param rotx
    caption="x-rot"
    hint="Rotates yz-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param roty
    caption="y-rot"
    hint="Rotates zx-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param rotz
    caption="z-rot"
    hint="Rotates xy-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param Magnification
    enum="auto" "z-low locked" "z-high locked" "free"
    hint="If auto then a surrounding around z-value will be magnified. If z-low is locked only \
          z-high will be acted on. If z-high is locked only z-low will be acted on. \
          If free you have to manage it by balancing z-dist."
    default=0
    max=3
    min=0
  endparam
  
  param inside
    caption="Inside filter."
    default=false
    hint="Shall be activated if inside coloring shall be used. Gives the same effect as \
          Color scaling = 1.0. The set will be solid."
  endparam
  
  param colscale
    caption="Color scaling."
    hint="The control over the coloring of the set according to the initial parameter +a.\
          Between 0 and 1. If 1 the color is solid."
    default=0.97
    max=1.0
    min=0
  endparam
  
  param solid
    caption="Solid outer color"
    hint="Gives only one color outside the set. Default is true. It is the fastest option."
    default=true
  endparam
  
  param dist
    caption="z-dist"
    hint="The distance in z-direction that shall be plotted. Default is 4.0"
    default=4.0
  endparam
  
  param zaxis
    enum="Screen-width" "Screen-height" "Free"
    default=1
    hint="Length in pixels of z-axis. Can be as Screen-width or Screen-height or free. \
          If free choose the length-factor in z-length. Default is Screen-height. \
          If free then z-axis is calculated by Screenwidth/zlengthfactor."
  endparam
  
  param zlength
    caption="z-length-factor"
    hint="Is active if zaxis if Free. If the pattern is too messy choose a lower value here. \
    default is 2.0  The length of axis is calculated by dividing Screenwidth by \
    zlengthfactor"
    default=2.0
    min=1e-10
  endparam  
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=100.0
  endparam
}

MandelN(XAXIS) {
init:
  complex z=#pixel
  complex oldz=0
loop:
  oldz=z
  z=z*z+#pixel
bailout:
  |z-oldz|>@bailout
default:
  title = "MandelN"
  periodicity=0
  maxiter=1000
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=1E-5
  endparam
  
}



NMCool {
init:
  complex n=@power
  complex m=@power-1
  complex r=@root
  complex t=0
  complex s=0
  int count=0
if !@pixelinit
  if @biblio==0
    if @auto
      complex z=(((@power-1)/(@power-2))*@root)^(1/@power)
    else
      complex z=@initz
    endif
  elseif @biblio==1
    if @auto
      z=1
      repeat
        oldz=z
        s=sin(z^n)
        t=cos(z^n)
        z=z-cabs(s+t-r)/(n*z^m*(t-s))
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=1
      endif
    else
      complex z=@initz
    endif
  elseif @biblio==2
    if @auto
      z=1
      repeat
        t=n*z
        oldz=z
        z=z-(tan(t)+log(cabs(t))+sin(t)-r)/(n*(1/(cos(t))^2+1/t+cos(t)))
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=1
      endif
    else
      complex z=@initz
    endif
  endif
else
  z=#pixel
endif
  complex oldz=z
loop:
  oldz=z
  if @biblio==0
    z=1/n*((n-2)*z+r*z^-(m))+@pixfunc(#pixel)
  elseif @biblio==1
    s=sin(z^n)
    t=cos(z^n)
    z=z-cabs(s+t-r)/(n*z^m*(t-s))+@pixfunc(#pixel)
  elseif @biblio==2
    t=n*z
    z=z-(tan(t)+log(cabs(t))+sin(t)-r)/(n*(1/(cos(t))^2+1/t+cos(t)))+@pixfunc(#pixel)
  endif

bailout:
  |z-oldz|>@bailout
  
switch:
  type="NJCool"
  seed=#pixel
  power=power
  root=root
  pixfunc=pixfunc
  bailout=bailout
  biblio=biblio

default:
  title = "NMCool"
  periodicity=0
  maxiter=100
  
  func pixfunc
    caption="Pixel func"
    default=ident()
    hint="Function that works on c (#pixel)"
  endfunc
  
  param biblio
    enum="z^n spec" "abs(sinz^n+cosz^n)" "tan(nz)+ln(nz)+sin(nz)"
    hint="The basic element. n is the power."
    default=0
  endparam
  
  param power
    caption="degree"
    hint="The degree of the polynom."
    default=(3.0,0)
  endparam
  
  param auto
    caption="auto-init"
    default=true
    hint="Gives automatic initiation. If false initz is used."
  endparam  
  
  param pixelinit
    caption="pixel init"
    default=false
    hint="z initiates by the actual pixelvalue."
  endparam

  param initz
    caption="initz"
    default=(3.141592653589793,0)
  endparam
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=1E-5
  endparam
  
  param root
    caption="root"
    default=(0.9,0)
  endparam
}


NMSharp {
init:
  complex n=@power
  complex m=@power-1
  complex r=@root
  complex t=0
  complex s=0
  complex u=0
  complex v=0
  complex oldz=0
  int count=0
if !@pixelinit
  if @biblio==0
    if @auto
      complex z=r^(1/n)
    else
      complex z=@initz
    endif
  elseif @biblio==1
    if @auto
      complex z=(asin(r))^(1/n)
    else
      complex z=@initz
    endif
  elseif @biblio==2
    if @auto
      complex z=asin(r^(1/n))
    else
      complex z=@initz
    endif
  elseif @biblio==3
    if @auto
      complex z=acos(r^(1/n))
    else
      complex z=@initz
    endif
  elseif @biblio==4
    if @auto
      z=1
      repeat
        oldz=z
        s=sin(z^n)
        t=cos(z^n)
        z=z-(s+t-r)/(n*z^m*(t-s))
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=1
      endif
    else
      complex z=@initz
    endif
  elseif @biblio==5
    if @auto
      z=1
      repeat
        t=n*z
        oldz=z
        z=z-(sin(t)+1/(t)-cos(t)-r)/(n*(cos(t) - 1/t^2+sin(t)))
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=pi
      endif
    else
      complex z=@initz
    endif
  elseif @biblio==6
    if @auto
      z=1
      repeat
        oldz=z
        t=sin(n*z)
        z=z-(t-r*e^(n*z))/(n*(cos(n*z)-t))
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=log(r)
      endif
    else
      complex z=@initz
    endif
  elseif @biblio==7
    if @auto
      z=1
      repeat
        oldz=z
        t=n*z
        z=z-(n^z-sin(t)-r)/(n*(log(n)*n^(z-1)-cos(t)))
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=1
      endif
    else
      complex z=@initz
    endif
  elseif @biblio==8
    if @auto
      z=asin(log(abs(r))/n)
    else
      complex z=@initz
    endif
  elseif @biblio==9
    if @auto
      z=1
      repeat
        t=n*z
        oldz=z
        z=z-(sin(t)+log(cabs(t))-r)/(n*(cos(t)+1/cabs(t)))
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=1
      endif
    else
      complex z=@initz
    endif
  elseif @biblio==10
    if @auto
      z=1
      repeat
        t=n*z
        s=e^t
        oldz=z
        z=z-(s-log(t)-r)/(n*s-1/t)
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=1
      endif
    else
      complex z=@initz
    endif
 elseif @biblio==11
    if @auto
      z=1
      repeat
        t=n*z
        s=sin(t)
        u=log(t)
        v=1/n^z
        oldz=z
        z=z-(z^(-n)+v-s^(-1)-u^(-1)-r)/(n*(cos(t)*s^(-2)-z^(-(n+1)))+u^(-2)*z^(-1)-log(n)*v)
        count=count+1
      until (count==30)||(|z-oldz|<@bailout)
      if count>29
        z=1
      endif
    else
      complex z=@initz
    endif
    z=z-(z^(-n)+v-s^(-1)-u^(-1)-r)/(n*(cos(t)*s^(-2)-z^(-(n+1)))+u^(-2)*z^(-1)-log(n)*v)
  endif
else
  z=#pixel
endif
  complex oldz=z
loop:
  oldz=z
  if @biblio==0
    z=1/n*(m*z+r*z^-m)+@pixfunc(#pixel)
  elseif @biblio==1
    t=z^n
    z=z-(sin(t)-r)/(n*z^m*cos(t))+@pixfunc(#pixel)
  elseif @biblio==2
    t=sin(z)
    z=z-(t^n-r)/(n*t^m*cos(z))+@pixfunc(#pixel)
  elseif @biblio==3
    t=z^n
    z=z+(cos(t)-r)/(n*z^m*sin(t))+@pixfunc(#pixel)
  elseif @biblio==4
    s=sin(z^n)
    t=cos(z^n)
    z=z-(s+t-r)/(n*z^m*(t-s))+@pixfunc(#pixel)
  elseif @biblio==5
    t=n*z
    z=z-(sin(t)+1/(t)-cos(t)-r)/(n*(cos(t) - 1/t^2+sin(t)))+@pixfunc(#pixel)
  elseif @biblio==6
    t=sin(n*z)
    z=z-(t-r*e^(n*z))/(n*(cos(n*z)-t))+@pixfunc(#pixel)
  elseif @biblio==7
    t=n*z
    z=z-(n^z-sin(t)-r)/(n*(log(n)*n^(z-1)-cos(t)))+@pixfunc(#pixel)
  elseif @biblio==8
    z=z-(1-r/e^(n*sin(z)))/(n*cos(z))+@pixfunc(#pixel)
  elseif @biblio==9
    t=n*z
    z=z-(sin(t)+log(cabs(t))-r)/(n*(cos(t)+1/cabs(t)))+@pixfunc(#pixel)
  elseif @biblio==10
    t=n*z
    s=e^t
    z=z-(s-log(t)-r)/(n*s-1/t)+@pixfunc(#pixel)
  elseif @biblio==11
    t=n*z
    s=sin(t)
    u=log(t)
    v=1/n^z
    z=z-(z^(-n)+v-s^(-1)-u^(-1)-r)/(n*(cos(t)*s^(-2)-z^(-(n+1)))+u^(-2)*z^(-1)-log(n)*v) \
    +@pixfunc(#pixel)
  endif
  
bailout:
  |z-oldz|>@bailout
  
switch:
  type="NJSharp"
  seed=#pixel
  power=power
  root=root
  pixfunc=pixfunc
  bailout=bailout
  biblio=biblio
  
default:
  title = "NMSharp"
  periodicity=0
  maxiter=100
  
  func pixfunc
    caption="Pixel func"
    default=ident()
    hint="Function that works on c (#pixel)"
  endfunc
  
  param biblio
    enum="z^n" "sin(z^n)" "(sin(z))^n" "cos(z^n)" "sin(z^n)+cos(z^n)" "sin(nz)+1/nz-cos(nz)" \
    "(sin(nz)/e^nz" "n^z-sin(nz)" "e^(nsin(z))" "sin(nz)+ln(abs(nz))" "e^nz-ln(abs(nz))" \
    "Grand"
    hint="The basic element. n is the power."
    default=0
  endparam
  
  param power
    caption="degree"
    hint="The degree of the polynom."
    default=(3.0,0)
  endparam
  
  param auto
    caption="auto-init"
    default=true
    hint="Gives automatic initiation. If false initz is used."
  endparam
  
  param pixelinit
    caption="pixel init"
    default=false
    hint="z initiates by the actual pixelvalue."
  endparam
  
  param initz
    caption="initz"
    default=(3.141592653589793,0)
    hint="Is active only if auto is not activated."
  endparam
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=1E-5
  endparam
  
  param root
    caption="root"
    default=(0.9,0)
  endparam
}

Blend {

;z=af1(z)^m+bf2(z)^n+cf3(z)^o+f(c)
init:
  complex z=@zinit
  complex zold=0
  complex aa=0
  complex bb=0
  complex cc=0
loop:
  zold=z
  if @a!=0
    aa=@a*@f1(zold)^@m
  endif
  if @b!=0
    bb=@b*@f2(zold)^@n
  endif
  if @c!=0
    cc=@c*@f3(zold)^@o
  endif
  z=aa+bb+cc+@f(#pixel)
    
bailout:
    (!@newton && (|z|<@bailout))||(@newton && (|z-zold|>1/@bailout)&&(|z|<@bailout))
    
switch:
  type="BlendJulia"
  seed=#pixel
  f1=f1
  f2=f2
  f3=f3
  f=f
  a=a
  m=m
  b=b
  n=n
  c=c
  o=o
  zinit=zinit
  newton=newton
  bailout=bailout
  
  
default:
  title = "Blend"
  periodicity=0
  
  func f1
    caption="func1"
    default=ident()
    hint="function for z1"
  endfunc
  
  func f2
    caption="func2"
    default=ident()
    hint="function for z2"
  endfunc
  
  func f3
    caption="func3"
    default=ident()
    hint="function for z3"
  endfunc
  
  func f
    caption="pix-func"
    default=ident()
    hint="function pixel. If recip the figure will be inverted."
  endfunc
  
  param a
    caption="a"
    default=(1,0)
    hint="const for z1"
  endparam
  
  param m
    caption="m"
    default=(2,0)
    hint="exp for z1"
  endparam
  
  param b
    caption="b"
    default=(0,0)
    hint="const for z2"
  endparam
  
  param n
    caption="n"
    default=(1,0)
    hint="exp for z2"
  endparam
  
  param c
    caption="c"
    default=(0,0)
    hint="const for z3"
  endparam
  
  param o
    caption="o"
    default=(0,0)
    hint="exp for z3"
  endparam
  
  param zinit
    caption="z-init"
    default=(0,0)
    hint="Initiation of z"
  endparam
  
  param newton
    caption="Diff bailout"
    default=false
    hint="Difference bailout"
  endparam
  
  param bailout
    caption="bailout"
    default=1e5
    hint="bailout"
  endparam
}


Mix {
; Corresponds to Jim Muth´s (Fractal of the day) MMix4-formula.
; z1 = (1 + k)*(a * z0^m + b * z0^n) + fn(#pixel)
; where k corresponds to his correcting p3 constant.
; I have added a constant h for correcting movement in the horisontal plane that sometimes
; will occur with high constants a and/or b. So the formula will look like:
; z1 = (1 + k)*(a * z0^m + b * z0^n) + h + fn(#pixel)
init:
  if @auto
    if (@a*@b)==0
      complex z=0
    elseif @n==@m
      complex z=0
    else
      complex z=((-@n*@b)/(@m*@a))^(1/(@m-@n))
    endif
  else
    complex z=@zinit
  endif
  complex zold=0
  complex aa=0
  complex bb=0

loop:
  zold=z
  if @a!=0
    aa=@a*zold^@m
  endif
  if @b!=0
    bb=@b*zold^@n
  endif
  z=(@yb+1)*(aa+bb)+@xb+@fn(#pixel)
  
bailout:
    (!@newton && (|z|<@bailout))||(@newton && (|z-zold|>1/@bailout)&&(|z|<@bailout))
    
switch:
  type="JMix"
  fn=fn
  a=a
  m=m
  b=b
  n=n
  xb=xb
  yb=yb
  newton=newton
  seed=#pixel
  bailout=bailout

  
default:
  title = "Mix"
  periodicity=0
  method=multipass
  
  func fn
    caption="Function"
    default=ident()
    hint="function that works on the pixelvalue"
  endfunc
  
  param a
    caption="a"
    default=(1,0)
    hint="const before z1"
  endparam
  
  param m
    caption="m"
    default=(2,0)
    hint="exp for z1"
  endparam
  
  param b
    caption="b"
    default=(0,0)
    hint="const before z2"
  endparam
  
  param n
    caption="n"
    default=(1,0)
    hint="exp for z2"
  endparam
  
  param auto
    caption="Auto-init"
    default=true
    hint="Auto init"
  endparam
  
  
  param zinit
    caption="z-init"
    default=(0,0)
    hint="Initiation of z"
  endparam
  
  param xb
    caption="Value for x-dir"
    default=(0,0)
    hint="Horiz balance. Normally the highest of a and b but with opposite sign. Use it for \
          extreme values of a or b."
  endparam
  
  param yb
    caption="Const"
    default=(0,0)
    hint="Corresponds to Jim´s P3."
  endparam
  
  param newton
    caption="Diff bailout"
    default=false
    hint="Difference bailout"
  endparam
  
  param bailout
    caption="bailout"
    default=1e5
    hint="bailout"
  endparam
}


NJCool {
init:
  complex n=@power
  complex m=@power-1
  complex r=@root
  complex t=0
  complex s=0
  complex z=#pixel
  complex oldz=z
  
loop:
  oldz=z
  if @biblio==0
    z=1/n*((n-2)*z+r*z^-(m))+@pixfunc(@seed)
  elseif @biblio==1
    s=sin(z^n)
    t=cos(z^n)
    z=z-cabs(s+t-r)/(n*z^m*(t-s))+@pixfunc(@seed)
  elseif @biblio==2
    t=n*z
    z=z-(tan(t)+log(cabs(t))+sin(t)-r)/(n*(1/(cos(t))^2+1/t+cos(t)))+@pixfunc(@seed)
  endif

bailout:
  |z-oldz|>@bailout
  
switch:
  type="NMCool"
  power=power
  root=root
  pixfunc=pixfunc
  bailout=bailout
  biblio=biblio
  
default:
  title = "NJCool"
  periodicity=0
  maxiter=100
  
  func pixfunc
    caption="Pixel func"
    default=ident()
    hint="Function that works on c (#pixel)"
  endfunc
  
  param biblio
    enum="z^n spec" "abs(sinz^n+cosz^n)" "tan(nz)+ln(nz)+sin(nz)"
    hint="The basic element. n is the power."
    default=0
  endparam
  
  param power
    caption="degree"
    hint="The degree of the polynom."
    default=(3,0)
  endparam

  param seed
    caption="seed"
    default=(-0.5,0)
  endparam
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=1E-5
  endparam
  
  param root
    caption="root"
    default=(0.9,0)
  endparam
}


NJSharp {
init:
  complex n=@power
  complex m=@power-1
  complex r=@root
  complex t=0
  complex s=0
  z=#pixel
  complex oldz=z
loop:
  oldz=z
  if @biblio==0
    z=1/n*(m*z+r*z^-m)+@pixfunc(@seed)
  elseif @biblio==1
    t=z^n
    z=z-(sin(t)-r)/(n*z^m*cos(t))+@pixfunc(@seed)
  elseif @biblio==2
    t=sin(z)
    z=z-(t^n-r)/(n*t^m*cos(z))+@pixfunc(@seed)
  elseif @biblio==3
    t=z^n
    z=z+(cos(t)-r)/(n*z^m*sin(t))+@pixfunc(@seed)
  elseif @biblio==4
    s=sin(z^n)
    t=cos(z^n)
    z=z-(s+t-r)/(n*z^m*(t-s))+@pixfunc(@seed)
  elseif @biblio==5
    t=n*z
    z=z-(sin(t)+1/(t)-cos(t)-r)/(n*(cos(t) - 1/t^2+sin(t)))+@pixfunc(@seed)
  elseif @biblio==6
    t=sin(n*z)
    z=z-(t-r*e^(n*z))/(n*(cos(n*z)-t))+@pixfunc(@seed)
  elseif @biblio==7
    t=n*z
    z=z-(n^z-sin(t)-r)/(n*(log(n)*n^(z-1)-cos(t)))+@pixfunc(@seed)
  elseif @biblio==8
    z=z-(1-r/e^(n*sin(z)))/(n*cos(z))+@pixfunc(@seed)
  elseif @biblio==9
    t=n*z
    z=z-(sin(t)+log(cabs(t))-r)/(n*(cos(t)+1/cabs(t)))+@pixfunc(@seed)
  elseif @biblio==10
    t=n*z
    s=e^t
    z=z-(s-log(t)-r)/(n*s-1/t)+@pixfunc(@seed)
  elseif @biblio==11
    t=n*z
    s=sin(t)
    u=log(t)
    v=1/n^z
    z=z-(z^(-n)+v-s^(-1)-u^(-1)-r)/(n*(cos(t)*s^(-2)-z^(-(n+1)))+u^(-2)*z^(-1)-log(n)*v) \
    +@pixfunc(@seed)
  endif
bailout:
  |z-oldz|>@bailout
  
switch:
  type="NMSharp"
  power=power
  root=root
  pixfunc=pixfunc
  bailout=bailout
  biblio=biblio
  
default:
  title = "NJSharp"
  periodicity=0
  maxiter=100
  
  func pixfunc
    caption="Pixel func"
    default=ident()
    hint="Function that works on c (#pixel)"
  endfunc
  
  param biblio
    enum="z^n" "sin(z^n)" "(sin(z))^n" "cos(z^n)" "sin(z^n)+cos(z^n)" "sin(nz)+1/nz-cos(nz)" \
    "(sin(nz)/e^nz" "n^z-sin(nz)" "e^(nsin(z))" "sin(nz)+ln(abs(nz))" "e^nz-ln(abs(nz))" \
    "Grand"
    hint="The basic element. n is the power."
    default=0
  endparam
  
  param power
    caption="degree"
    hint="The degree of the polynom."
    default=(3.0,0)
  endparam
  
  param seed
    caption="seed"
    default=(0,0)
  endparam
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=1E-5
  endparam
  
  param root
    caption="root"
    default=(0.9,0)
  endparam
}


Quaternion {
init:
  ccolscale=@colscale
  complex z=0
  complex zz=0
  complex zh=0
  complex zzh=0
  complex z1h=0
  bool setzero=false
  float rotx=0
  float roty=0
  float rotz=0
  float x1=0
  float y1=0
  float z1=0
  float rx=0
  float ry=0
  float z1=0
  float zlow=@zvalue-@dist/2
  float zdist=@dist/#magn
  float sinrotx=0
  float cosrotx=0
  float sinroty=0
  float cosroty=0
  float sinrotz=0
  float cosrotz=0
  if @Magnification==0
    zlow=@zvalue-zdist/2
  elseif @Magnification==1
    zlow=@zvalue-zdist
  elseif @Magnification==2
    zlow=@zvalue
  else
    zdist=@dist
  endif
  if @zaxis==0
    int zscreen=#width-1
  elseif @zaxis==1
    int zscreen=#height-1
  else 
    int zscreen=round(#width/@zlength)-1
  endif
  float scale = zdist/zscreen
  int nmax=zscreen+1
  int n=0
  int m=0
  bool nflag=false
  if @fdim>1
    zh=#pixel
  else
    z=#pixel
  endif
  if (@dim2==true)&&(@localdim2==false)
    nmax=1
    zlow=@zvalue
  elseif (@dim2==true)&&(@localdim2==true)
    nmax=1
  endif
if @fdim==3
  while (n<nmax)&&(nflag==false)
    z=scale*n+zlow+@ucoord*1i
    zh=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(zh)
         z1=real(z)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         zh=real(zh)+ry*1i
         z=rz+1i*@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=real(z)
         x1=real(zh)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         z=rz+1i*@ucoord
         zh=rx+1i*imag(zh)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(zh)
         y1=imag(zh)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         zh=rx+1i*ry
       endif
     endif 
     zz=z
     zzh=zh
      while (m<#maxiter)&&(|z|+|zh|<@bailout)
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+@c1i
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+@cjk
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+@c1i
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+@cjk
        z=z1h
      endif
      m=m+1
      endwhile
      if (|z|+|zh|)<@bailout
        nflag=true
      else
        nflag=false
      endif    
      m=0
      n=n+1
  endwhile
  z=zz
  zh=zzh
  if @inside==false
    if nflag==true
      z=scale*(n-1)*ccolscale+zlow+@ucoord*1i
      zh=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         y1=imag(zh)
         z1=real(z)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         zh=real(zh)+ry*1i
         z=rz+1i*@ucoord 
       endif
       if @roty!=0
         z1=real(z)
         x1=real(zh)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         z=rz+1i*@ucoord
         zh=rx+1i*imag(zh)
       endif
       if @rotz!=0
         x1=real(zh)
         y1=imag(zh)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         zh=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    setzero=true
  endif
elseif @fdim==2
  while (n<nmax)&&(nflag==false)
    z=(scale*n+zlow)*1i+@ucoord
    zh=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(zh)
         z1=imag(z)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         zh=real(zh)+ry*1i
         z=rz*1i+@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=imag(z)
         x1=real(zh)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         z=rz*1i+@ucoord
         zh=rx+1i*imag(zh)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(zh)
         y1=imag(zh)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         zh=rx+1i*ry
       endif
     endif
     zz=z
     zzh=zh
      while (m<#maxiter)&&(|z|+|zh|<@bailout)
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+@c1i
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+@cjk
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+@c1i
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+@cjk
        z=z1h
      endif
        m=m+1
      endwhile
      m=0
      if |z|+|zh|<@bailout
        nflag=true
      else
        nflag=false
      endif    
      m=0
      n=n+1
  endwhile
  z=zz
  zh=zzh
  if @inside == false
    if nflag==true
      z=(scale*(n-1)*ccolscale+zlow)*1i+@ucoord
      zh=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         y1=imag(zh)
         z1=imag(z)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         zh=real(zh)+ry*1i
         z=rz*1i+@ucoord
       endif
       if @roty!=0
         z1=imag(z)
         x1=real(zh)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         z=rz*1i+@ucoord
         zh=rx+1i*imag(zh)
       endif
       if @rotz!=0
         x1=real(zh)
         y1=imag(zh)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         zh=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    setzero=true
  endif
elseif @fdim==1
  while (n<nmax)&&(nflag==false)
    zh=scale*n+zlow+@ucoord*1i
    z=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(z)
         z1=real(zh)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         z=real(z)+ry*1i
         zh=rz+1i*@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=real(zh)
         x1=real(z)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         zh=rz+1i*@ucoord
         z=rx+1i*imag(z)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(z)
         y1=imag(z)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         z=rx+1i*ry
       endif
     endif
     zz=z
     zzh=zh
      while (m<#maxiter)&&(|z|+|zh|<@bailout)
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+@c1i
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+@cjk
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+@c1i
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+@cjk
        z=z1h
      endif
      m=m+1
      endwhile
      m=0
      if |z|+|zh|<@bailout
        nflag=true
      else
        nflag=false
      endif    
      m=0
    n=n+1
  endwhile
  z=zz
  zh=zzh
  if @inside==false
    if nflag==true
      zh=scale*(n-1)*ccolscale+zlow+@ucoord*1i
      z=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         y1=imag(z)
         z1=real(zh)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         z=real(z)+ry*1i
         zh=rz+1i*@ucoord
       endif
       if @roty!=0
         z1=real(zh)
         x1=real(z)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         zh=rz+1i*@ucoord
         z=rx+1i*imag(z)
       endif
       if @rotz!=0
         x1=real(z)
         y1=imag(z)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         z=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    setzero=true
  endif
else
  while (n<nmax)&&(nflag==false)
    zh=@ucoord+(scale*n+zlow)*1i
    z=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(z)
         z1=imag(zh)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         z=real(z)+ry*1i
         zh=rz*1i+@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=imag(zh)
         x1=real(z)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         zh=rz*1i+@ucoord
         z=rx+1i*imag(z)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(z)
         y1=imag(z)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         z=rx+1i*ry
       endif
     endif 
     zz=z
     zzh=zh
      while (m<#maxiter)&&(|z|+|zh|<@bailout)
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+@c1i
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+@cjk
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+@c1i
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+@cjk
        z=z1h
      endif
      m=m+1
      endwhile
      m=0
      if |z|+|zh|<@bailout
        nflag=true
      else
        nflag=false
      endif   
      m=0
    n=n+1
  endwhile
  z=zz
  zh=zzh
  if @inside==false
    if nflag==true
      zh=@ucoord+(scale*(n-1)*ccolscale+zlow)*1i
      z=#pixel
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
       if @rotx!=0
         y1=imag(z)
         z1=imag(zh)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         z=real(z)+ry*1i
         zh=rz*1i+@ucoord
       endif
       if @roty!=0
         z1=imag(zh)
         x1=real(z)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         zh=rz*1i+@ucoord
         z=rx+1i*imag(z)
       endif
       if @rotz!=0
         x1=real(z)
         y1=imag(z)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         z=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    setzero=true
  endif
endif

loop:
  if setzero==false
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+@c1i
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+@cjk
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+@c1i
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+@cjk
        z=z1h
      endif
  else
    z=0
    zh=0
  endif
  
bailout:
  (|z|+|zh|)<@bailout
  
switch:
  type="ToQuaternion"
  c1i=#pixel
  cjk=cjk
  fdim=fdim
  hyper=hyper
  dim2=dim2
  localdim2=localdim2
  zvalue=zvalue
  ucoord=ucoord
  rotx=rotx
  roty=roty
  rotz=rotz
  magnification=Magnification
  inside=inside
  colscale=colscale
  solid=solid
  dist=dist
  zaxis=zaxis
  zlength=zlength
  bailout=bailout
  
default:
  title = "Quaternion"
  maxiter=14
  

  
  param fdim
    enum="zh-real" "zh-imag" "z-real" "z-imag"
    hint="The axis that shall point into the fourth dimension"
    default=1
    max=3
    min=0
  endparam
  
  param c1i
    caption="c1i"
    default=(-0.5,-0.5)
    hint="The (real,i)-component in c."
  endparam
  
  param cjk
    caption="cjk"
    default=(0,0)
    hint="The (j,k)-component in c."
  endparam
  
  param hyper
    caption="Hypercomplex"
    default=false
    hint="If set the hypercomplex math will be used. Otherwise the quaternion."
  endparam
  
  param dim2
    caption="2-dimensional"
    hint="Renders 2-dimensional Quaternion or Hypercomplex"
    default=false
  endparam
  
  param localdim2
    caption="Local dim2-pos."
    hint="If true the landing position in dim-2 will be there you are. Otherwise it will \
          where z-value is. The default is z-value."
    default=false
  endparam
  
  param zvalue
    caption="z-value"
    hint="The midpoint at the z-axis. Default is 0."
    default=0.0
  endparam
  
  param ucoord
    caption="u-coord"
    hint="The coordinat of the fourth dimensions axis."
    default=0.0
  endparam
  
  param rotx
    caption="x-rot"
    hint="Rotates yz-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param roty
    caption="y-rot"
    hint="Rotates zx-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param rotz
    caption="z-rot"
    hint="Rotates xy-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param Magnification
    enum="auto" "z-low locked" "z-high locked" "free"
    hint="If auto then a surrounding around z-value will be magnified. If z-low is locked only \
          z-high will be acted on. If z-high is locked only z-low will be acted on. \
          If free you have to manage it by balancing z-dist."
    default=0
    max=3
    min=0
  endparam
  
  param inside
    caption="Inside filter."
    default=false
    hint="Shall be activated if inside coloring shall be used. Gives the same effect as \
          Color scaling = 1.0. The set will be solid."
  endparam
  
  param colscale
    caption="Color scaling."
    hint="The control over the coloring of the set according to the initial parameter +a.\
          Between 0 and 1. If 1 the color is solid."
    default=0.97
    max=1.0
    min=0
  endparam
  
  param solid
    caption="Solid outer color"
    hint="Gives only one color outside the set. Default is true. It is the fastest option."
    default=true
  endparam
  
  param dist
    caption="z-dist"
    hint="The distance in z-direction that shall be plotted. Default is 4.0"
    default=4.0
  endparam
  
  param zaxis
    enum="Screen-width" "Screen-height" "Free"
    default=1
    hint="Length in pixels of z-axis. Can be as Screen-width or Screen-height or free. \
          If free choose the length-factor in z-length. Default is Screen-height. \
          If free then z-axis is calculated by Screenwidth/zlengthfactor."
  endparam
  
  param zlength
    caption="z-length-factor"
    hint="Is active if zaxis if Free. If the pattern is too messy choose a lower value here. \
    default is 2.0  The length of axis is calculated by dividing Screenwidth by \
    zlengthfactor"
    default=2.0
    min=1e-10
  endparam  
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=100.0
  endparam
}

ToQuaternion(XAXIS) {
init:
  complex z=0
  
loop:
  z=z^2+#pixel
  
bailout:
  |z|<@bailout
  
switch:
  type="quaternion"
  c1i=#pixel
  cjk=cjk
  fdim=fdim
  hyper=hyper
  dim2=dim2
  localdim2=localdim2
  zvalue=zvalue
  ucoord=ucoord
  rotx=rotx
  roty=roty
  rotz=rotz
  magnification=Magnification
  inside=inside
  colscale=colscale
  solid=solid
  dist=dist
  zaxis=zaxis
  zlength=zlength
  bailout=bailout
  
default:
  title = "ToQuaternion"
  
  param fdim
    enum="zh-real" "zh-imag" "z-real" "z-imag"
    hint="The axis that shall point into the fourth dimension"
    default=1
    max=3
    min=0
  endparam
  
  param c1i
    caption="c1i"
    default=(-0.5,-0.5)
    hint="The (real,i)-component in c."
  endparam
  
  param cjk
    caption="cjk"
    default=(0,0)
    hint="The (j,k)-component in c."
  endparam
  
  param hyper
    caption="Hypercomplex"
    default=false
    hint="If set the hypercomplex math will be used. Otherwise the quaternion."
  endparam
  
  param dim2
    caption="2-dimensional"
    hint="Renders 2-dimensional Quaternion or Hypercomplex"
    default=false
  endparam
  
  param localdim2
    caption="Local dim2-pos."
    hint="If true the landing position in dim-2 will be there you are. Otherwise it will \
          where z-value is. The default is z-value."
    default=false
  endparam
  
  param zvalue
    caption="z-value"
    hint="The midpoint at the z-axis. Default is 0."
    default=0.0
  endparam
  
  param ucoord
    caption="u-coord"
    hint="The coordinat of the fourth dimensions axis."
    default=0.0
  endparam
  
  param rotx
    caption="x-rot"
    hint="Rotates yz-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param roty
    caption="y-rot"
    hint="Rotates zx-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param rotz
    caption="z-rot"
    hint="Rotates xy-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param Magnification
    enum="auto" "z-low locked" "z-high locked" "free"
    hint="If auto then a surrounding around z-value will be magnified. If z-low is locked only \
          z-high will be acted on. If z-high is locked only z-low will be acted on. \
          If free you have to manage it by balancing z-dist."
    default=0
    max=3
    min=0
  endparam
  
  param inside
    caption="Inside filter."
    default=false
    hint="Shall be activated if inside coloring shall be used. Gives the same effect as \
          Color scaling = 1.0. The set will be solid."
  endparam
  
  param colscale
    caption="Color scaling."
    hint="The control over the coloring of the set according to the initial parameter +a.\
          Between 0 and 1. If 1 the color is solid."
    default=0.97
    max=1.0
    min=0
  endparam
  
  param solid
    caption="Solid outer color"
    hint="Gives only one color outside the set. Default is true. It is the fastest option."
    default=true
  endparam
  
  param dist
    caption="z-dist"
    hint="The distance in z-direction that shall be plotted. Default is 4.0"
    default=4.0
  endparam
  
  param zaxis
    enum="Screen-width" "Screen-height" "Free"
    default=1
    hint="Length in pixels of z-axis. Can be as Screen-width or Screen-height or free. \
          If free choose the length-factor in z-length. Default is Screen-height. \
          If free then z-axis is calculated by Screenwidth/zlengthfactor."
  endparam
  
  param zlength
    caption="z-length-factor"
    hint="Is active if zaxis if Free. If the pattern is too messy choose a lower value here. \
    default is 2.0  The length of axis is calculated by dividing Screenwidth by \
    zlengthfactor"
    default=2.0
    min=1e-10
  endparam  
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=100.0
  endparam
  
}


MQuaternion{
init:
  ccolscale=@colscale
  complex zh=0
  complex z1h=0
  complex a=0
  complex b=0
  float rotx=0
  float roty=0
  float rotz=0
  float rotz=0
  float x1=0
  float y1=0
  float z1=0
  float rx=0
  float ry=0
  float z1=0
  float zlow=@zvalue-@dist/2
  float zdist=@dist/#magn
  float sinrotx=0
  float cosrotx=0
  float sinroty=0
  float cosroty=0
  float sinrotz=0
  float cosrotz=0
  if @Magnification==0
    zlow=@zvalue-zdist/2
  elseif @Magnification==1
    zlow=@zvalue-zdist
  elseif @Magnification==2
    zlow=@zvalue
  else
    zdist=@dist
  endif
  if @zaxis==0
    int zscreen=#width-1
  elseif @zaxis==1
    int zscreen=#height-1
  else 
    int zscreen=round(#width/@zlength)-1
  endif
  float scale = zdist/zscreen
  int nmax=zscreen+1
  int n=0
  int m=0
  bool nflag=false
  if @fdim>1
    a=#pixel
  else
    b=#pixel
  endif
  if (@dim2==true)&&(@localdim2==false)
    nmax=1
    zlow=@zvalue
  elseif (@dim2==true)&&(@localdim2==true)
    nmax=1
  endif
if @fdim==3
  while (n<nmax)&&(nflag==false)
    b=scale*n+zlow+@ucoord*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      a=#pixel
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(a)
         z1=real(b)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         a=real(a)+ry*1i
         b=rz+1i*@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=real(b)
         x1=real(a)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         b=rz+1i*@ucoord
         a=rx+1i*imag(a)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(a)
         y1=imag(a)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         a=rx+1i*ry
       endif
     endif
     z=0
     zh=0
      while (m<#maxiter)&&(|z|+|zh|<@bailout)
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+a
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+b
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+a
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+b
        z=z1h
      endif
        m=m+1
      endwhile
      m=0
      if |z|+|zh|<@bailout
        nflag=true
      else
        nflag=false
      endif
    n=n+1
  endwhile
  if @inside==false
    if nflag==true
      b=scale*(n-1)*ccolscale+zlow+@ucoord*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      a=#pixel
       if @rotx!=0
         y1=imag(a)
         z1=real(b)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         a=real(a)+ry*1i
         b=rz+1i*@ucoord 
       endif
       if @roty!=0
         z1=real(b)
         x1=real(a)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         b=rz+1i*@ucoord
         a=rx+1i*imag(a)
       endif
       if @rotz!=0
         x1=real(a)
         y1=imag(a)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         a=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    b=0
    a=0
    z=0
    zh=0
  endif
elseif @fdim==2
  while (n<nmax)&&(nflag==false)
    b=(scale*n+zlow)*1i+@ucoord
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      a=#pixel
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(a)
         z1=imag(b)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         a=real(a)+ry*1i
         b=rz*1i+@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=imag(b)
         x1=real(a)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         b=rz*1i+@ucoord
         a=rx+1i*imag(a)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(a)
         y1=imag(a)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         a=rx+1i*ry
       endif
     endif  
     z=0
     zh=0
      while (m<#maxiter)&&(|z|+|zh|<@bailout)
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+a
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+b
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+a
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+b
        z=z1h
      endif
        m=m+1
      endwhile
      m=0
      if |z|+|zh|<@bailout
        nflag=true
      else
        nflag=false
      endif
    n=n+1
  endwhile
  if @inside == false
    if nflag==true
      b=(scale*(n-1)*ccolscale+zlow)*1i+@ucoord
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      a=#pixel
       if @rotx!=0
         y1=imag(a)
         z1=imag(b)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         a=real(a)+ry*1i
         b=rz*1i+@ucoord
       endif
       if @roty!=0
         z1=imag(b)
         x1=real(a)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         b=rz*1i+@ucoord
         a=rx+1i*imag(a)
       endif
       if @rotz!=0
         x1=real(a)
         y1=imag(a)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         a=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    b=0
    a=0
    z=0
    zh=0
  endif
elseif @fdim==1
  while (n<nmax)&&(nflag==false)
    a=scale*n+zlow+@ucoord*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      b=#pixel
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(b)
         z1=real(a)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         b=real(b)+ry*1i
         a=rz+1i*@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0

           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=real(a)
         x1=real(b)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         a=rz+1i*@ucoord
         b=rx+1i*imag(b)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(b)
         y1=imag(b)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         b=rx+1i*ry
       endif
     endif  
     z=0
     zh=0
      while (m<#maxiter)&&(|z|+|zh|<@bailout)
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+a
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+b
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+a
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+b
        z=z1h
      endif
        m=m+1
      endwhile
      m=0
      if |z|+|zh|<@bailout
        nflag=true
      else
        nflag=false
      endif
    n=n+1
  endwhile
  if @inside == false
    if nflag==true 
      a=scale*(n-1)*ccolscale+zlow+@ucoord*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      b=#pixel
       if @rotx!=0
         y1=imag(b)
         z1=real(a)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         b=real(b)+ry*1i
         a=rz+1i*@ucoord
       endif
       if @roty!=0
         z1=real(a)
         x1=real(b)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         a=rz+1i*@ucoord
         b=rx+1i*imag(b)
       endif
       if @rotz!=0
         x1=real(b)
         y1=imag(b)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         b=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    a=0
    b=0
    z=0
    zh=0
  endif
else
  while (n<nmax)&&(nflag==false)
    a=@ucoord+(scale*n+zlow)*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      b=#pixel
       if @rotx!=0
         if @rotx==90.0
           sinrotx=1.0
           cosrotx=0
         elseif @rotx==-90
           sinrotx=-1.0
           cosrotx=0
         elseif abs(@rotx)==180
           sinrotx=0
           cosrotx=-1
         else
           rotx=#pi*@rotx/180.0
           sinrotx=sin(rotx)
           cosrotx=cos(rotx)
         endif
         y1=imag(b)
         z1=imag(a)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         b=real(b)+ry*1i
         a=rz*1i+@ucoord
       endif
       if @roty!=0
         if @roty==90.0
           sinroty=1.0
           cosroty=0
         elseif @roty==-90
           sinroty=-1.0
           cosroty=0
         elseif abs(@roty)==180
           sinroty=0
           cosroty=-1
         else
           roty=#pi*@roty/180.0
           sinroty=sin(roty)
           cosroty=cos(roty)
         endif
         z1=imag(a)
         x1=real(b)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         a=rz*1i+@ucoord
         b=rx+1i*imag(b)
       endif
       if @rotz!=0
         if @rotz==90.0
           sinrotz=1.0
           cosrotz=0
         elseif @rotz==-90
           sinrotz=-1.0
           cosrotz=0
         elseif abs(@rotz)==180
           sinrotz=0
           cosrotz=-1
         else
           rotz=#pi*@rotz/180.0
           sinrotz=sin(rotz)
           cosrotz=cos(rotz)
         endif
         x1=real(b)
         y1=imag(b)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         b=rx+1i*ry
       endif
     endif  
     z=0
     zh=0
      while (m<#maxiter)&&(|z|+|zh|<@bailout)
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+a
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+b
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+a
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+b
        z=z1h
      endif
        m=m+1
      endwhile
      m=0
      if |z|+|zh|<@bailout
        nflag=true
      else
        nflag=false
      endif
    n=n+1
  endwhile
  if @inside==false
    if nflag==true 
      a=@ucoord+(scale*(n-1)*ccolscale+zlow)*1i
    if (@rotx!=0)||(@roty!=0)||(@rotz!=0)
      b=#pixel
       if @rotx!=0
         y1=imag(b)
         z1=imag(a)
         ry=y1*cosrotx-z1*sinrotx
         rz=y1*sinrotx+z1*cosrotx
         b=real(b)+ry*1i
         a=rz*1i+@ucoord
       endif
       if @roty!=0
         z1=imag(a)
         x1=real(b)
         rz=z1*cosroty-x1*sinroty
         rx=z1*sinroty+x1*cosroty
         a=rz*1i+@ucoord
         b=rx+1i*imag(b)
       endif
       if @rotz!=0
         x1=real(b)
         y1=imag(b)
         rx=x1*cosrotz-y1*sinrotz
         ry=x1*sinrotz+y1*cosrotz
         b=rx+1i*ry
       endif
     endif
    endif
  endif
  if (nflag==false)&&(@solid==true)&&(@dim2==false)
    a=0
    b=0
    z=0
    zh=0
  endif
endif
z=0

loop:
      if @hyper==false
        z1h=z*z-real(zh)^2-imag(zh)^2+a
        zh=2*(real(z)*real(zh)+flip(real(z)*imag(zh)))+b
        z=z1h
      else
        z1h=z*z-real(zh)^2-imag(zh)^2-flip(2*real(zh)*imag(zh))+a
        zh=2*(real(z)*real(zh)-imag(z)*imag(zh)+flip(real(z)*imag(zh)+imag(z)*real(zh)))+b
        z=z1h
      endif
  
bailout:
  |z|+|zh|<@bailout
  
default:
  title = "MQuaternion"
  
  param fdim
    enum="c1" "ci" "cj" "ck"
    hint="The axis that shall point into the fourth dimension"
    default=3
  endparam
  
  param hyper
    caption="Hypercomplex"
    default=false
    hint="If set then hypercomplex math is used instead of quaternion math."
  endparam
  
  param dim2
    caption="2-dimensional"
    hint="Renders 2-dimensional cubic"
    default=false
  endparam
  
  param localdim2
    caption="Local dim2-pos."
    hint="If true the landing position in dim-2 will be there you are. Otherwise it will \
          where z-value is. The default is z-value."
    default=false
  endparam
  
  param zvalue
    caption="z-value"
    hint="The midpoint at the z-axis. Default is 0."
    default=0.0
  endparam
  
  param ucoord
    caption="u-coord"
    hint="The coordinat of the fourth dimensions axis."
    default=0.0
  endparam
  
  param rotx
    caption="x-rot"
    hint="Rotates yz-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param roty
    caption="y-rot"
    hint="Rotates zx-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  param rotz
    caption="z-rot"
    hint="Rotates xy-plane."
    default=0.0
    min=-360.0
    max=360.0
  endparam
  
  
  param Magnification
    enum="auto" "z-low locked" "z-high locked" "free"
    hint="If auto then a surrounding around z-value will be magnified. If z-low is locked only \
          z-high will be acted on. If z-high is locked only z-low will be acted on. \
          If free you have to manage it by balancing z-dist."
    default=0
    max=3
    min=0
  endparam
  
  param inside
    caption="Inside filter."
    default=false
    hint="Shall be activated if inside coloring shall be used. Gives the same effect as \
          Color scaling = 1.0. The set will be solid."
  endparam
  
  param colscale
    caption="Color scaling."
    hint="The control over the coloring of the set according to the initial parameter +a.\
          Between 0 and 1. If 1 the color is solid."
    default=0.97
    max=1.0
    min=0
  endparam
  
  param solid
    caption="Solid outer color"
    hint="Gives only one color outside the set. Default is true. It is the fastest option. \
          Mathematically no outer structures is allowed that do not belong to the overlapping \
          two sets from +a and -a (Cubic Connectedness Locus). We do an exception in 2-d \
          because we shall be able to explore the set in a normal way."
    default=true
  endparam
  
  param dist
    caption="z-dist"
    hint="The distance in z-direction that shall be plotted. Default is 4.0"
    default=4.0
  endparam
  
  param zaxis
    enum="Screen-width" "Screen-height" "Free"
    default=1
    hint="Length in pixels of z-axis. Can be as Screen-width or Screen-height or free. \
          If free choose the length-factor in z-length. Default is Screen-height. \
          If free then z-axis is calculated by Screenwidth/zlengthfactor."
  endparam
  
  param zlength
    caption="z-length-factor"
    hint="Is active if zaxis if Free. If the pattern is too messy choose a lower value here. \
    default is 2.0  The length of axis is calculated by dividing Screenwidth by \
    zlengthfactor"
    default=2.0
    min=1e-10
  endparam  
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=100.0
  endparam
}



MandelLevels { ;Use Multipass or Onepass linear for drawing
init:
if @nothreads==true
  z=0
  aa=#pixel
else
  if real(#screenmax)/imag(#screenmax)>4/3
    float scale=3.0/imag(#screenmax)/#magn
  else
    float scale=4.0/real(#screenmax)/#magn
  endif
  bool flag=false
  bool flag2=false
  complex z=0
  complex a=#pixel
  complex aa=@col
  complex a1=a+scale
  complex a2=a-scale
  complex a3=a+flip(scale)
  complex a4=a-flip(scale)
  complex a5=a1+flip(scale)
  complex a6=a1-flip(scale)
  complex a7=a2+flip(scale)
  complex a8=a2-flip(scale)
  int max=#maxiter
  int c=0
  int ac=0
  repeat
    c=c+1
    z=z^@n+@f1(a)
  until (c==max)||(|z|>@bailout)
  if c==max
    flag=true
  endif
  ac=c
  if flag==false
    c=0
    z=0
    repeat
      c=c+1
      z=z^@n+@f1(a1)
    until (c==max)||(|z|>@bailout)
    if (c>ac)&&(c<max)
      flag2=true
      aa=a1
    endif
    c=0
    z=0
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(a2)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a2
      endif
      c=0
      z=0
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(a3)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a3
      endif
      c=0
      z=0
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(a4)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a4
      endif
      c=0
      z=0
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(a5)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a5
      endif
      c=0
      z=0
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(a6)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a6
      endif
      c=0
      z=0
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(a7)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a7
      endif
      c=0
      z=0
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(a8)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a8
      endif
      c=0
      z=0
    endif
  endif
  if flag==true
    aa=#pixel
  endif
endif
  
loop:

  z = z^@n + @f1(aa)

bailout:
  |z|<@bailout
  
switch:
  type="JuliaLevels"
  seed=#pixel
  nothreads=nothreads
  f1=f1
  col=col
  n=n
  bailout=bailout

default:
  title = "MandelLevels"
  method=multipass
  periodicity=0
  center=(-0.5,0)

  
  func f1
    caption="Function"
    hint="Function for parameter c."
    default=ident()
  endfunc
  
  param nothreads
    caption="No threads"
    hint="The routine will work as a normal mandelbrot."
    default=false
  endparam
  
  param col
    caption="Colour"
    hint="Choose color between bands with geographic coords"
    default=(0.0,0.0)
  endparam
  
  param n
    caption="exponent"
    hint="2 is the normal Mandelbrot."
    default=(2,0)
  endparam
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=4.0
  endparam
}



JuliaLevels { ;Use Multipass or Onepass linear drawing.
init:
if @nothreads==true
  z=#pixel
else
  if real(#screenmax)/imag(#screenmax)>4/3
    float scale=3.0/imag(#screenmax)/#magn
  else
    float scale=4.0/real(#screenmax)/#magn
  endif
  bool flag=false
  bool flag2=false
  complex z=0
  complex a=#pixel
  complex aa=@col
  complex a1=a+scale
  complex a2=a-scale
  complex a3=a+flip(scale)
  complex a4=a-flip(scale)
  complex a5=a1+flip(scale)
  complex a6=a1-flip(scale)
  complex a7=a2+flip(scale)
  complex a8=a2-flip(scale)
  int max=#maxiter
  int c=0
  int ac=0
  complex z=a
  repeat
    c=c+1
    z=z^@n+@f1(@seed)
  until (c==max)||(|z|>@bailout)
  if c==max
    flag=true
  endif
  ac=c
  if flag==false
    c=0
    z=a1
    repeat
      c=c+1
      z=z^@n+@f1(@seed)
    until (c==max)||(|z|>@bailout)
    if (c>ac)&&(c<max)
      flag2=true
      aa=a1
    endif
    c=0
    z=a2
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(@seed)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a2
      endif
      c=0
      z=a3
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(@seed)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a3
      endif
      c=0
      z=a4
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(@seed)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a4
      endif
      c=0
      z=a5
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(@seed)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a5
      endif
      c=0
      z=a6
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(@seed)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a6
      endif
      c=0
      z=a7
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(@seed)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a7
      endif
      c=0
      z=a8
    endif
    if flag2==false
      repeat
        c=c+1
        z=z^@n+@f1(@seed)
      until (c==max)||(|z|>@bailout)
      if (c>ac)&&(c<max)
        flag2=true
        aa=a8
      endif
      c=0
      z=0
    endif
  endif
  if flag==true
    z=#pixel
  else
    z=aa
  endif
endif
loop:

  z = z^@n + @f1(@seed)

bailout:
  |z|<@bailout
  
switch: 
  type="MandelLevels"
  f1=f1
  nothreads=nothreads
  col=col
  n=n
  bailout=bailout
  
default:
  title = "JuliaLevels"
  method=multipass
  periodicity=0
  center=(0,0)

  
  func f1
    caption="Function"
    hint="Function for parameter c."
    default=ident()
  endfunc
  
  param nothreads
    caption="No threads"
    hint="The routine will work as a normal mandelbrot."
    default=false
  endparam
  
  param seed
    caption="Seed."
    hint="Coordinates for c."
    default=(-0.5,0.6)
  endparam
  
  param col
    caption="Colour"
    hint="Choose color between bands with geographic coords"
    default=(0.0,0.0)
  endparam
  
  param n
    caption="exponent"
    hint="2 is the normal Mandelbrot."
    default=(2,0)
  endparam
  
  param bailout
    caption="bailout"
    hint="bailout"
    default=4.0
  endparam
}

GuruGuru{
init:
  complex z=@zinit

loop:
  z=1+@func1(z)/@func2(#pixel)
bailout:
  |z|<@bailout
default:
  title = "GuruGuru"
  angle=270
  
func func1
  caption="function 1"
  default=ident()
endfunc

func func2
  caption="function 2"
  default=ident()
endfunc

  
param zinit
  caption="z-init"
  default=(1,0)
endparam

param bailout
  caption="bailout"
  default=4.0
endparam

}


Eulerian{
init:
  complex z=@zinit
  complex c=#pixel
  complex n=@ninit
  c=@func4(c)
loop:
  n=n+1
  z=@func3(@func2(z+1/(n*c*z))^@func1(n*c*z))
bailout:
  |z|<@bailout
default:
  title = "Eulerian"
  periodicity=0
  
func func1
  caption="f^f1(g(z))"
  default=ident()
endfunc  

func func2
  caption="f2(f)^f1(g(z))"
  default=ident()
endfunc 

func func3
  caption="f3(f2(f)^f1(g(z))"
  default=ident()
endfunc 
  
func func4
  caption="f(c)"
  default=ident()
endfunc   
  
param zinit
  caption="z-init"
  default=(1.0,0)
endparam

param ninit
  caption="n-init"
  default=(0,0)
endparam

param bailout
  caption="bailout"
  default=4.0
endparam

}



StarEasy {
init:
  complex m=1/@n
  complex z=0
  complex oldz=0
  if @autoinit==0
    z=@r^m
  elseif @autoinit==1
    z=(@r*(1-@n))^m
  else
    z=@zinit
  endif
  complex c=@f2(#pixel)

loop:
  oldz=z
  a=@f1(z)
  z=m*(a-@r*a^(1-@n))+c
bailout:
  |z-oldz|>@bailout
  
switch:
  type="StarEasyJulia"
  seed=#pixel
  autoinit=autoinit
  zinit=zinit
  f1=f1
  f2=f2
  r=r
  n=n
  bailout=bailout

  
default:
  title = "Star Easy"
  periodicity=0
  
  func f1
    caption="func1"
    default=ident()
    hint="z-func"
  endfunc
  
  func f2
    caption="func2"
    default=ident()
    hint="pixel-func"
  endfunc
  
  param n
    caption="Degree"
    default=(5.0,0)
    hint="degree of polynom"
  endparam
  
  param autoinit
    enum="Newton-harmonic" "Mandel-harmonic" "No Auto"
    default=0
    hint="Auto-init of z. Newton-harmonic gives equalized Newtonstructur. \
          Mandel-harmonic gives nonperturbated Mandelbrots."
  endparam
    
  param r
    caption="Root"
    default=(1,0)
    hint="Root"
  endparam
  
  param zinit
    caption="z-init"
    default=(1,0)
    hint="Init of z"
  endparam
  
  param bailout
    caption="bailout"
    default=1E-5
    hint="bailout"
  endparam
}


StarEasyJulia {
init:
  complex m=1/@n
  complex z=#pixel
  complex oldz=0
  complex c=@f2(@seed)

loop:
  oldz=z
  a=@f1(z)
  z=m*(a-@r*a^(1-@n))+c
bailout:
  |z-oldz|>@bailout
  
switch:
  type="StarEasy"
  f1=f1
  f2=f2
  autoinit=autoinit
  zinit=zinit
  r=r
  n=n
  bailout=bailout

  
default:
  title = "Star Easy Julia"
  periodicity=0
  
  func f1
    caption="func1"
    default=ident()
    hint="z-func"
  endfunc
  
  func f2
    caption="func2"
    default=ident()
    hint="pixel-func"
  endfunc
  
  param seed
    caption="Seed"
    default=(0,0)
    hint="Seed for Julia"
  endparam
  
  param n
    caption="Degree"
    default=(5.0,0)
    hint="degree of polynom"
  endparam
  
  param autoinit
    enum="Newton-harmonic" "Mandel-harmonic" "No Auto"
    default=0
    hint="Auto-init of z. Newton-harmonic gives equalized Newtonstructur. \
          Mandel-harmonic gives nonperturbated Mandelbrots."
  endparam
    
  param r
    caption="Root"
    default=(1,0)
    hint="Root"
  endparam
  
  param zinit
    caption="z-init"
    default=(1,0)
    hint="Init of z"
  endparam
  
  param bailout
    caption="bailout"
    default=1E-5
    hint="bailout"
  endparam
}



Div {
init:
  if @pixelinit==false
    complex z=@zinit
  else
    complex z=#pixel
  endif
loop:
  z=(@f1(z)+@const)/@f2(z)+#pixel
  
bailout:
  |z|<@bailout
  
switch:
  type="JDiv"
  f1=f1
  f2=f2
  const=const
  bailout=bailout
  seed=#pixel
  
default:
  title = "Div"
  periodicity=0
  
  func f1
    caption="func1"
    default=exp()
    hint="(f1+Const)/f2+c"
  endfunc
  
  func f2
    caption="func2"
    default=ident()
    hint="(f1+Const)/f2+c"
  endfunc
  
  param const
    caption="Constant"
    default=(0,0)
    hint="(f1+Const)/f2+c"
  endparam
  
  param pixelinit
    caption="Pixel-init"
    default=false
    hint="If z shall be initiated with the current pixelvalue (c)."
  endparam
  
  param zinit
    caption="z-init"
    default=(1,0)
    hint="Initial z"
  endparam
  
  param bailout
    caption="bailout"
    default=1e6
    hint="bailout"
  endparam
}



JDiv {
init:
  complex z=#pixel
loop:
  z=(@f1(z)+@const)/@f2(z)+@seed
bailout:
  |z|<@bailout
  
switch:
  type="Div"
  f1=f1
  f2=f2
  const=const
  bailout=bailout
  
default:
  title = "JDiv"
  periodicity=0
  
  func f1
    caption="func1"
    default=exp()
    hint="(f1+Const)/f2+c"
  endfunc
  
  func f2
    caption="func2"
    default=ident()
    hint="(f1+Const)/f2+c"
  endfunc
  
  param const
    caption="Constant"
    default=(0,0)
    hint="(f1+Const)/f2+c"
  endparam
  
  param seed
    caption="seed"
    default=(1,0)
    hint="Julia-seed"
  endparam
  
  param bailout
    caption="bailout"
    default=1e6
    hint="bailout"
  endparam
}



JMix {
; Corresponding Newton to Jim Muth´s (Fractal of the day) MMix4-formula.
; z1 = (1 + k)*(a * z0^m + b * z0^n) + fn(#pixel)
; where k corresponds to his correcting p3 constant.
; I have added a constant h for correcting movement in the horisontal plane that sometimes
; will occur with high constants a and/or b. So the formula will look like:
; z1 = (1 + k)*(a * z0^m + b * z0^n) + h + fn(#pixel)
init:
  complex z=#pixel
  complex zold=0
  complex aa=0
  complex bb=0

loop:
  zold=z
  if @a!=0
    aa=@a*zold^@m
  endif
  if @b!=0
    bb=@b*zold^@n
  endif
  z=(@yb+1)*(aa+bb)+@xb+@fn(@seed)
  
bailout:
    (!@newton && (|z|<@bailout))||(@newton && (|z-zold|>1/@bailout)&&(|z|<@bailout))
    
switch:
  type="Mix"
  fn=fn
  a=a
  m=m
  b=b
  n=n
  xb=xb
  yb=yb
  newton=newton
  bailout=bailout

  
default:
  title = "JMix"
  periodicity=0
  method=multipass
  periodicity=0
  
  func fn
    caption="Function"
    default=ident()
    hint="function that works on the pixelvalue"
  endfunc
  
  param seed
    caption="Seed"
    default=(0,0)
    hint="Juliaseed"
  endparam
  
  param a
    caption="a"
    default=(1,0)
    hint="const before z1"
  endparam
  
  param m
    caption="m"
    default=(2,0)
    hint="exp for z1"
  endparam
  
  param b
    caption="b"
    default=(0,0)
    hint="const before z2"
  endparam
  
  param n
    caption="n"
    default=(1,0)
    hint="exp for z2"
  endparam
  
  param auto
    caption="Auto-init"
    default=true
    hint="Auto init"
  endparam
  
  
  param zinit
    caption="z-init"
    default=(0,0)
    hint="Initiation of z"
  endparam
  
  param xb
    caption="Value for x-dir"
    default=(0,0)
    hint="Horiz. balance"
  endparam
  
  param yb
    caption="Const"
    default=(0,0)
    hint="Corresponds to Jim´s P3."
  endparam
  
  param newton
    caption="Diff bailout"
    default=false
    hint="Difference bailout"
  endparam
  
  param bailout
    caption="bailout"
    default=1e5
    hint="bailout"
  endparam
}



Garth {
init:
  complex z=0
  if @pixin
    z=#pixel
  else
    z=@init
  endif
loop:
  z=z^(4*z^(4*z))+z^(6*z)+z+@funcp(#pixel)
bailout:
  |z|<@bailout
  
switch:
  type="GarthJ"
  bailout=bailout
  pixin=pixin
  init=init
  funcp=funcp
  seed=#pixel

default:
  title = "Garth"
  periodicity=0
  method=multipass
  
  func funcp
    caption="pix-func"
    default=ident()
  endfunc
  
  param pixin
    caption="pixel-init"
    default=true
  endparam
  
  param init
    caption="z-init"
    default=(0,0)
  endparam
  
  param bailout
    caption="bailout"
    default=4.0
  endparam
}


GarthJ {
init:
  complex z=#pixel
loop:
  z=z^(4*z^(4*z))+z^(6*z)+z+@funcp(@seed)
bailout:
  |z|<@bailout
  
switch:
  type="Garth"
  bailout=bailout
  pixin=pixin
  init=init

default:
  title = "GarthJ"
  periodicity=0
  method=multipass
  
  func funcp
    caption="pix-func"
    default=ident()
  endfunc
  
  param seed
    caption="seed"
    default=(0,0)
  endparam
  
  param pixin
    caption="pixel-init"
    default=true
  endparam
  
  param init
    caption="z-init"
    default=(0,0)
  endparam
  
  param bailout
    caption="bailout"
    default=4.0
  endparam
}


BlendJulia {

;z=af1(z)^m+bf2(z)^n+cf3(z)^o+f(c)
init:
  complex z=#pixel
  complex zold=0
  complex aa=0
  complex bb=0
  complex cc=0
loop:
  zold=z
  if @a!=0
    aa=@a*@f1(zold)^@m
  endif
  if @b!=0
    bb=@b*@f2(zold)^@n
  endif
  if @c!=0
    cc=@c*@f3(zold)^@o
  endif
  z=aa+bb+cc+@f(@seed)
    
bailout:
    (!@newton && (|z|<@bailout))||(@newton && (|z-zold|>1/@bailout)&&(|z|<@bailout))
    
switch:
  type="Blend"
  f1=f1
  f2=f2
  f3=f3
  f=f
  a=a
  m=m
  b=b
  n=n
  c=c
  o=o
  zinit=zinit
  newton=newton
  bailout=bailout
    
    
  
default:
  title = "BlendJulia"
  periodicity=0
  
  func f1
    caption="func1"
    default=ident()
    hint="function for z1"
  endfunc
  
  func f2
    caption="func2"
    default=ident()
    hint="function for z2"
  endfunc
  
  func f3
    caption="func3"
    default=ident()
    hint="function for z3"
  endfunc
  
  func f
    caption="pix-func"
    default=ident()
    hint="function pixel. If recip the figure will be inverted."
  endfunc
  
  param seed
    caption="seed"
    default=(0,0)
    hint="The seed for the julia."
  endparam
  
  param a
    caption="a"
    default=(1,0)
    hint="const for z1"
  endparam
  
  param m
    caption="m"
    default=(2,0)
    hint="exp for z1"
  endparam
  
  param b
    caption="b"
    default=(0,0)
    hint="const for z2"
  endparam
  
  param n
    caption="n"
    default=(1,0)
    hint="exp for z2"
  endparam
  
  param c
    caption="c"
    default=(0,0)
    hint="const for z3"
  endparam
  
  param o
    caption="o"
    default=(0,0)
    hint="exp for z3"
  endparam
  
  param zinit
    caption="z-init"
    default=(0,0)
    hint="Initiation of z"
  endparam
  
  param newton
    caption="Diff bailout"
    default=false
    hint="Difference bailout"
  endparam
  
  param bailout
    caption="bailout"
    default=1e5
    hint="bailout"
  endparam
  
}


exp1Julia {
init:
  complex z=#pixel
loop:
  z=@a^@func1(z)+@func2(@seed)

bailout:
  |z|<@bailout
  
switch:
  type="exp1"
  ini=ini
  a=a
  bailout=bailout
  func1=func1
  func2=func2

default:
  title = "exp1Julia"
  periodicity=0
  
  param seed
    caption="seed"
    default=(0,0)
    hint="julia-seed"
  endparam

  param a
    caption="value"
    default=(0.1,0.0)
  endparam
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
  
  param ini
    caption = "init"
    default=(0,0)
  endparam
  
  func func1
    caption="function 1"
    default=ident()
  endfunc
  
  func func2
    caption="function 2"
    default=ident()
  endfunc
}


exp2Julia {
init:
  complex z=#pixel
loop:
  z=@a*@func2(@seed^@func1(z))+@b

bailout:
  |z|<@bailout

switch:
  type="exp2"
  ini=ini
  a=a
  b=b
  bailout=bailout
  func1=func1
  func2=func2

default:
  title = "exp2Julia"
  periodicity=0
  
  param seed
    caption="seed"
    default=(1.8,-0.7)
    hint="Julia-seed"
  endparam

  param a
    caption="value 1"
    default=(1.0,0.0)
  endparam
  
  param b
    caption="value 2"
    default=(1.0,0.0)
  endparam
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
  
  param ini
    caption = "init"
    default=(0,0)
  endparam
  
  func func1
    caption="function 1"
    default=ident()
  endfunc
  
  func func2
    caption="function 2"
    default=ident()
  endfunc
  
}


Inverse1Julia {
init:
  complex z=#pixel
loop:
  z=recip(sqr(@myfunc(z))*@seed)
bailout:
  |z|<@bailout
  
switch:
  type="Inverse1"
  myfunc=myfunc
  bailout=bailout
  ini=ini

default:
  title = "Inverse1Julia"
  periodicity=0
  
  func myfunc
    caption="function"
    default=sin()
  endfunc
  
  param seed
    caption="seed"
    default=(1.0,0.2)
    hint="Julia-seed"
  endparam
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
  
  param ini
    caption = "init"
    default=(1,0)
  endparam
}


Inverse2Julia {
init:
  complex z=#pixel
loop:
  z=recip(@myfunc(z)*@seed)
bailout:
  |z|<@bailout
  
switch:
  type="Inverse2"
  ini=ini
  myfunc=myfunc
  bailout=bailout
  
default:
  title = "Inverse2Julia"
  periodicity=0
  
  func myfunc
    caption="function"
    default=sin()
  endfunc
  
  param seed
    caption="seed"
    default=(-0.4,0)
    hint="Julia-seed"
  endparam
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
  
  param ini
    caption = "init"
    default=(1,0)
  endparam
}


Inverse3Julia {
init:
  complex z=#pixel
loop:
  z=recip(sqr(@myfunc(z)))*@a+sqr(@myfunc2(z))*@b+@seed
bailout:
  |z|<@bailout
  
switch:
  type="Inverse3"
  ini=ini
  myfunc=myfunc
  myfunc2=myfunc2
  a=a
  b=b
  bailout=bailout

default:
  title = "Inverse3Julia"
  periodicity=0
  
  func myfunc
    caption="function"
    default=sin()
  endfunc
  
  func myfunc2
    caption="function2"
    default=cos()
  endfunc
  
  param seed
    caption="seed"
    default=(0,0)
    hint="Julia-seed"
  endparam
  
  param a
    caption="a"
    default=1.0
  endparam
  
  param b
    caption="b"
    default=1.0
  endparam
  
  param bailout
    caption="bailout"
    default=100.0
  endparam
  
  param ini
    caption = "init"
    default=(1,0)
  endparam
}
